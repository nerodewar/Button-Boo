<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Button Boo (v1)</title>

  <!-- Retro arcade font (online). If you want offline, download and self-host. -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg0:#020617;
      --bg1:#06102a;
      --bg2:#0b1d4a;

      --text:#F4F8FF;
      --muted:rgba(214,230,255,0.80);

      --glass: rgba(10, 24, 58, 0.38);
      --edge: rgba(255,255,255,0.14);

      --radius: 22px;
      --shadow: 0 24px 70px rgba(0,0,0,.55);

      --arcadeRed1:#ff2d2d;
      --arcadeRed2:#b00018;
      --arcadeBlue1:#2aa8ff;
      --arcadeBlue2:#0a4ee6;

      --tap: 92px; /* toddler-safe tap size */
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }

    body{
      margin:0;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background: linear-gradient(180deg, var(--bg0), var(--bg1) 55%, var(--bg2));
      overflow:hidden;
    }

    /* Canvas covers the whole screen */
    #stage{
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      touch-action: manipulation;
    }

    /* UI overlay */
    .ui{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      pointer-events:none; /* enable interactions per element */
    }

    .panel{
      width:min(760px, 100%);
      border-radius: var(--radius);
      background:
        radial-gradient(900px 420px at 20% 12%, rgba(255,255,255,0.08), rgba(0,0,0,0) 55%),
        linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02)),
        var(--glass);
      border:1px solid rgba(255,255,255,0.12);
      box-shadow: var(--shadow);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      overflow:hidden;
      padding:22px;
      pointer-events:auto;
    }

    .screen{ display:none; }
    .screen.active{ display:block; }

    .stack{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:16px;
    }

    .titleArcade{
      font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      letter-spacing: .8px;
      text-shadow: 0 0 18px rgba(255,255,255,0.10), 0 0 36px rgba(143,243,255,0.12);
      margin:0;
      font-size: clamp(18px, 3.2vw, 30px);
      line-height: 1.25;
      text-align:center;
    }

    .copy{
      max-width: 58ch;
      margin: 0 auto;
      text-align:center;
      color: var(--muted);
      line-height: 1.65;
      font-size: 1rem;
    }
    .copy ul{
      list-style: none;
      padding: 0;
      margin: 14px auto 0;
      display: grid;
      gap: 8px;
      width: min(560px, 100%);
    }
    .copy li{
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      border-radius: 14px;
      padding: 10px 12px;
      text-align: left;
    }

    .startBtn{
      font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      letter-spacing: .8px;
      font-size: clamp(14px, 2.2vw, 18px);
      padding: 18px 22px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.14);
      cursor:pointer;
      background:
        radial-gradient(220px 100px at 20% 0%, rgba(255,255,255,0.20), rgba(0,0,0,0) 70%),
        linear-gradient(180deg, rgba(255,255,255,0.10), rgba(0,0,0,0) 42%),
        linear-gradient(180deg, var(--arcadeBlue1), var(--arcadeBlue2));
      color: rgba(244,248,255,0.98);
      text-shadow: 0 0 16px rgba(255,255,255,0.18);
      box-shadow:
        0 20px 50px rgba(0,0,0,0.42),
        0 0 0 1px rgba(255,255,255,0.10) inset,
        0 0 30px rgba(42,168,255,0.20);
      transition: transform .12s ease, filter .12s ease;
      min-width: 180px;
      -webkit-tap-highlight-color: transparent;
    }
    .startBtn:active{ transform: translateY(2px) scale(0.99); filter: brightness(0.98); }

    /* Play HUD (bottom) */
    .hud{
      position:fixed;
      left:0;
      right:0;
      bottom:0;
      padding: 14px 14px calc(14px + env(safe-area-inset-bottom));
      display:flex;
      justify-content:center;
      pointer-events:none;
    }
    .hudInner{
      pointer-events:auto;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:14px;
      flex-wrap:wrap;

      padding: 12px 14px;
      border-radius: 18px;
      background: rgba(10, 24, 58, 0.28);
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      box-shadow: 0 18px 46px rgba(0,0,0,.35);
    }

    .arcadeText{
      font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: clamp(12px, 2.0vw, 16px);
      letter-spacing: .6px;
      font-weight: 800;
      color: rgba(244,248,255,0.95);
      text-shadow: 0 0 18px rgba(255,255,255,0.10);
      user-select:none;
    }

    .arcadeBtn{
      width: max(var(--tap), 92px);
      height: max(var(--tap), 92px);
      border-radius: 999px;
      border:1px solid rgba(255,255,255,0.16);
      cursor:pointer;
      position:relative;
      user-select:none;
      -webkit-tap-highlight-color: transparent;

      background:
        radial-gradient(circle at 35% 28%, rgba(255,255,255,0.55), rgba(255,255,255,0.12) 18%, rgba(0,0,0,0) 45%),
        linear-gradient(180deg, rgba(255,255,255,0.14), rgba(0,0,0,0) 45%),
        linear-gradient(180deg, var(--arcadeRed1), var(--arcadeRed2));

      box-shadow:
        0 18px 44px rgba(0,0,0,0.40),
        0 0 0 1px rgba(255,255,255,0.10) inset,
        0 0 26px rgba(255,45,45,0.20);
      transform: translateY(0);
      transition: transform .12s ease, filter .12s ease, box-shadow .12s ease;
    }
    .arcadeBtn:active{
      transform: translateY(2px) scale(0.985);
      filter: brightness(0.98);
      box-shadow:
        0 10px 24px rgba(0,0,0,0.34),
        0 0 0 1px rgba(255,255,255,0.10) inset,
        0 0 22px rgba(255,45,45,0.18);
    }

    .hint{
      margin-top: 2px;
      font-size: 0.92rem;
      color: rgba(214,230,255,0.70);
      text-align:center;
    }

    /* Reduce motion */
    @media (prefers-reduced-motion: reduce){
      .panel{ backdrop-filter:none; -webkit-backdrop-filter:none; }
    }
  </style>
</head>

<body>
  <canvas id="stage" aria-label="Button Boo star stage"></canvas>

  <audio id="bgm" preload="auto" loop>
    <source src="assets/music/button-boo.mp3" type="audio/mpeg">
  </audio>

  <div class="ui" id="ui">
    <!-- WELCOME -->
    <div class="panel screen active" id="welcome">
      <div class="stack">
        <h1 class="titleArcade">Button Boo</h1>

        <div class="copy">
          <p><strong style="color:rgba(244,248,255,0.95);">This is a sensory cause-and-effect playground.</strong></p>
          <p>
            A first interaction with screens and a way for your little ones to develop Cause &amp; effect understanding,
        </li>Motor control, Sensory processing, Emotional safety with screens, without overstimulation nor “wrong” inputs.
          </p>
        </div>

        <button class="startBtn" id="startBtn" type="button" aria-label="Start Button Boo">
          START
        </button>

        <div class="hint">Tap START to begin.</div>
      </div>
    </div>

    <!-- PLAY (no center panel; just HUD) -->
    <div class="screen" id="play"></div>
  </div>

  <div class="hud" id="hud" style="display:none;">
    <div class="hudInner">
      <div class="arcadeText">Press to Play</div>
      <button class="arcadeBtn" id="redBtn" type="button" aria-label="Red arcade button"></button>
    </div>
  </div>

  <script>
    (() => {
      // ---------- Utilities ----------
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const lerpColor = (c1, c2, t) => ({
        r: lerp(c1.r, c2.r, t),
        g: lerp(c1.g, c2.g, t),
        b: lerp(c1.b, c2.b, t),
      });
      const toRGBA = (c, a=1) => `rgba(${c.r|0},${c.g|0},${c.b|0},${a})`;

      // Smooth cinematic easing (nice for long bloom)
      const easeInOutCubic = t => (t < 0.5) ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;
      const easeOutCubic = t => 1 - Math.pow(1 - t, 3);

      // ---------- DOM ----------
      const canvas = document.getElementById('stage');
      const ctx = canvas.getContext('2d', { alpha: true });

      const bgm = document.getElementById('bgm');
      const welcome = document.getElementById('welcome');
      const play = document.getElementById('play');
      const startBtn = document.getElementById('startBtn');
      const hud = document.getElementById('hud');
      const redBtn = document.getElementById('redBtn');

      // ---------- Sizing ----------
      let w = 0, h = 0, dpr = 1;

      function resize() {
        dpr = Math.min(2, window.devicePixelRatio || 1);
        w = Math.floor(window.innerWidth);
        h = Math.floor(window.innerHeight);
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      window.addEventListener('resize', resize, { passive: true });
      resize();

      // ---------- Starfield ----------
      // Multi-layer parallax stars (pre-generated)
      function makeStars(count, depthMin, depthMax) {
        const arr = [];
        for (let i = 0; i < count; i++) {
          arr.push({
            x: Math.random(),
            y: Math.random(),
            r: lerp(0.6, 1.8, Math.random()),
            a: lerp(0.25, 0.9, Math.random()),
            d: lerp(depthMin, depthMax, Math.random()), // depth
            tw: Math.random() * Math.PI * 2,
            twSp: lerp(0.12, 0.35, Math.random())
          });
        }
        return arr;
      }
      const starsNear = makeStars(110, 0.18, 0.35);
      const starsMid  = makeStars(170, 0.35, 0.70);
      const starsFar  = makeStars(230, 0.70, 1.15);

      function drawStarLayer(stars, t, driftX, driftY) {
        for (const s of stars) {
          const tw = 0.75 + 0.25 * Math.sin(s.tw + t * s.twSp);
          const x = (s.x * w + driftX * (1/s.d)) % w;
          const y = (s.y * h + driftY * (1/s.d)) % h;
          const rr = s.r * tw;

          ctx.beginPath();
          ctx.fillStyle = `rgba(255,255,255,${s.a * tw})`;
          ctx.arc(x < 0 ? x + w : x, y < 0 ? y + h : y, rr, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // ---------- Star Entity (Canvas “volumetric” illusion) ----------
      // Curated palettes (always good-looking)
      const PALETTES = [
        // Icy Cyan / Lilac
        { core:{r:200,g:250,b:255}, plasma:{r:143,g:243,b:255}, corona:{r:168,g:160,b:255}, spark:{r:255,g:255,b:255} },
        // Gold / Peach
        { core:{r:255,g:240,b:210}, plasma:{r:255,g:210,b:120}, corona:{r:255,g:170,b:90},  spark:{r:255,g:255,b:255} },
        // Mint / Sky
        { core:{r:210,g:255,b:240}, plasma:{r:140,g:255,b:220}, corona:{r:120,g:200,b:255}, spark:{r:255,g:255,b:255} },
        // Rose / Lavender
        { core:{r:255,g:220,b:235}, plasma:{r:255,g:170,b:210}, corona:{r:200,g:170,b:255}, spark:{r:255,g:255,b:255} },
        // Deep Blue / Electric Cyan
        { core:{r:200,g:230,b:255}, plasma:{r:80,g:220,b:255},  corona:{r:120,g:150,b:255}, spark:{r:255,g:255,b:255} },
      ];

      // Current + target palette for smooth crossfade
      let palette = structuredClone(PALETTES[0]);
      let paletteFrom = structuredClone(palette);
      let paletteTo = structuredClone(palette);
      let paletteTweenT0 = 0;
      let paletteTweenDur = 800; // ms

      function pickNewPalette(nowMs) {
        const next = PALETTES[Math.floor(Math.random() * PALETTES.length)];
        paletteFrom = structuredClone(palette);
        paletteTo = structuredClone(next);
        paletteTweenT0 = nowMs;
      }

      function updatePalette(nowMs) {
        const t = clamp((nowMs - paletteTweenT0) / paletteTweenDur, 0, 1);
        const tt = easeOutCubic(t);
        palette = {
          core:  lerpColor(paletteFrom.core,  paletteTo.core,  tt),
          plasma:lerpColor(paletteFrom.plasma,paletteTo.plasma,tt),
          corona:lerpColor(paletteFrom.corona,paletteTo.corona,tt),
          spark: lerpColor(paletteFrom.spark, paletteTo.spark, tt)
        };
      }

      // Star entity params
      let star = {
        cx: 0,
        cy: 0,
        rBase: 0,
        // idle motion
        rot: 0,
        rot2: 0,
        // bloom scaling state
        scale: 1,
        state: 'idle', // 'idle' | 'bloomUp' | 'return'
        t0: 0,
        // timings
        bloomUpMs: 8000,
        returnMs: 2400
      };

      function computeStarLayout() {
        star.cx = w * 0.5;
        star.cy = h * 0.42; // slightly above center to leave room for HUD
        const minDim = Math.min(w, h);
        // base radius: large “entity in space” but not overwhelming
        star.rBase = clamp(minDim * 0.16, 90, 180);
      }
      computeStarLayout();
      window.addEventListener('resize', computeStarLayout, { passive: true });

      // Draw helpers
      function drawGlowCircle(x, y, r, color, alpha, blur) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = blur;
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function drawStarEntity(tSec, nowMs) {
        const r = star.rBase * star.scale;

        // Outer spill into space (screen-wide soft glow around star)
        const spill = ctx.createRadialGradient(star.cx, star.cy, r * 0.3, star.cx, star.cy, r * 2.4);
        spill.addColorStop(0.0, toRGBA(palette.corona, 0.18));
        spill.addColorStop(0.6, toRGBA(palette.plasma, 0.07));
        spill.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = spill;
        ctx.fillRect(0, 0, w, h);
        ctx.restore();

        // Corona (soft halo)
        const corona = ctx.createRadialGradient(star.cx, star.cy, r * 0.62, star.cx, star.cy, r * 1.10);
        corona.addColorStop(0.0, toRGBA(palette.corona, 0.22));
        corona.addColorStop(0.55, toRGBA(palette.corona, 0.12));
        corona.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = corona;
        ctx.beginPath();
        ctx.arc(star.cx, star.cy, r * 1.10, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Plasma swirl layer: multiple arcs rotated differently to fake turbulence
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.translate(star.cx, star.cy);

        // mask to star “body”
        ctx.beginPath();
        ctx.arc(0, 0, r * 0.78, 0, Math.PI * 2);
        ctx.clip();

        // base body gradient
        const body = ctx.createRadialGradient(0, 0, r * 0.05, 0, 0, r * 0.78);
        body.addColorStop(0.0, toRGBA(palette.core, 0.95));
        body.addColorStop(0.35, toRGBA(palette.plasma, 0.40));
        body.addColorStop(0.75, toRGBA(palette.corona, 0.18));
        body.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = body;
        ctx.fillRect(-r, -r, r*2, r*2);

        // swirl arcs (layer 1)
        ctx.rotate(star.rot);
        for (let i = 0; i < 18; i++) {
          const a0 = (i / 18) * Math.PI * 2;
          const a1 = a0 + lerp(0.12, 0.32, (Math.sin(tSec * 0.7 + i) + 1) / 2);
          const rr = lerp(r * 0.18, r * 0.72, (i % 6) / 5);
          ctx.lineWidth = lerp(2.0, 6.5, (i % 5) / 4);
          ctx.strokeStyle = toRGBA(palette.plasma, 0.10 + 0.10 * Math.sin(tSec * 0.9 + i));
          ctx.beginPath();
          ctx.arc(0, 0, rr, a0, a1);
          ctx.stroke();
        }

        // swirl arcs (layer 2, counter-rotation)
        ctx.rotate(-star.rot * 1.65 + star.rot2);
        for (let i = 0; i < 12; i++) {
          const a0 = (i / 12) * Math.PI * 2;
          const a1 = a0 + lerp(0.14, 0.40, (Math.cos(tSec * 0.65 + i * 1.7) + 1) / 2);
          const rr = lerp(r * 0.22, r * 0.70, ((i * 7) % 12) / 11);
          ctx.lineWidth = lerp(1.6, 5.2, (i % 4) / 3);
          ctx.strokeStyle = toRGBA(palette.corona, 0.08 + 0.08 * Math.cos(tSec * 0.8 + i));
          ctx.beginPath();
          ctx.arc(0, 0, rr, a0, a1);
          ctx.stroke();
        }

        // spark flecks inside (subtle)
        ctx.globalAlpha = 0.85;
        for (let i = 0; i < 22; i++) {
          const ang = tSec * 0.35 + i * 0.62;
          const pr = r * lerp(0.08, 0.70, (Math.sin(i * 12.3) + 1) / 2);
          const px = Math.cos(ang) * pr * 0.55;
          const py = Math.sin(ang * 1.12) * pr * 0.55;
          drawGlowCircle(px, py, lerp(0.8, 2.0, (Math.cos(tSec + i) + 1) / 2), toRGBA(palette.spark, 1), 0.14, 10);
        }

        ctx.restore();

        // Hot core nucleus
        const core = ctx.createRadialGradient(star.cx, star.cy, r * 0.02, star.cx, star.cy, r * 0.42);
        core.addColorStop(0.0, toRGBA(palette.core, 0.98));
        core.addColorStop(0.25, toRGBA(palette.core, 0.62));
        core.addColorStop(0.60, toRGBA(palette.plasma, 0.18));
        core.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = core;
        ctx.beginPath();
        ctx.arc(star.cx, star.cy, r * 0.42, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Small lens highlight (subtle, helps depth)
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const hl = ctx.createRadialGradient(star.cx - r*0.22, star.cy - r*0.22, r*0.03, star.cx - r*0.22, star.cy - r*0.22, r*0.36);
        hl.addColorStop(0.0, 'rgba(255,255,255,0.40)');
        hl.addColorStop(0.45, 'rgba(255,255,255,0.08)');
        hl.addColorStop(1.0, 'rgba(255,255,255,0)');
        ctx.fillStyle = hl;
        ctx.beginPath();
        ctx.arc(star.cx - r*0.12, star.cy - r*0.12, r*0.48, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // ---------- Interaction (only: bloom 3x over 8s, return 2.4s) ----------
      let running = true;
      let lastMs = performance.now();
      let allowInput = false; // only after start
      let tapThrottleT = 0;

      function startBloom(nowMs) {
        if (!allowInput) return;

        // If idle: start the bloom timeline.
        if (star.state === 'idle') {
          pickNewPalette(nowMs);
          star.state = 'bloomUp';
          star.t0 = nowMs;
          return;
        }

        // If already blooming/returning: re-roll palette only (throttled)
        if (nowMs - tapThrottleT > 500) {
          tapThrottleT = nowMs;
          pickNewPalette(nowMs);
        }
      }

      function updateBloom(nowMs) {
        if (star.state === 'idle') {
          // gentle idle breathing (small)
          const t = nowMs * 0.001;
          const breathe = 1 + 0.018 * Math.sin(t * 2 * Math.PI / 6.2);
          star.scale = breathe;
          return;
        }

        if (star.state === 'bloomUp') {
          const t = clamp((nowMs - star.t0) / star.bloomUpMs, 0, 1);
          const e = easeInOutCubic(t);
          star.scale = lerp(1.0, 3.0, e);

          if (t >= 1) {
            star.state = 'return';
            star.t0 = nowMs;
          }
          return;
        }

        if (star.state === 'return') {
          const t = clamp((nowMs - star.t0) / star.returnMs, 0, 1);
          const e = easeOutCubic(t);
          star.scale = lerp(3.0, 1.0, e);

          if (t >= 1) {
            star.state = 'idle';
            star.t0 = nowMs;
          }
        }
      }

      // ---------- Input (tap orb OR red button) ----------
      function inStarHit(x, y) {
        const dx = x - star.cx;
        const dy = y - star.cy;
        const r = star.rBase * 1.15; // generous hit area
        return (dx*dx + dy*dy) <= (r*r);
      }

      canvas.addEventListener('pointerdown', (e) => {
        if (!allowInput) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);
        if (inStarHit(x, y)) startBloom(performance.now());
      }, { passive:true });

      redBtn.addEventListener('click', () => startBloom(performance.now()));

      // ---------- Welcome / Start ----------
      async function startMusic() {
        try {
          if (bgm && bgm.paused) {
            bgm.volume = 0.45;
            await bgm.play();
          }
        } catch (e) {
          // Silent by design; user interaction typically enables audio next try.
        }
      }

      function setScreen(which) {
        welcome.classList.toggle('active', which === 'welcome');
        play.classList.toggle('active', which === 'play');
      }

      startBtn.addEventListener('click', async () => {
        await startMusic();
        setScreen('play');
        hud.style.display = 'flex';
        allowInput = true;
      });

      // ---------- Animation Loop ----------
      function drawBackground(tSec) {
        // Deep base gradients (subtle)
        const g = ctx.createLinearGradient(0, 0, 0, h);
        g.addColorStop(0,   '#020617');
        g.addColorStop(0.6, '#06102a');
        g.addColorStop(1,   '#0b1d4a');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, w, h);

        // Gentle drift (parallax)
        const driftX = Math.sin(tSec * 0.05) * 40 + Math.cos(tSec * 0.03) * 25;
        const driftY = Math.cos(tSec * 0.04) * 30 + Math.sin(tSec * 0.06) * 18;

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        drawStarLayer(starsFar,  tSec, driftX * 0.25, driftY * 0.25);
        drawStarLayer(starsMid,  tSec, driftX * 0.55, driftY * 0.55);
        drawStarLayer(starsNear, tSec, driftX * 0.95, driftY * 0.95);
        ctx.restore();

        // Nebula haze (very subtle)
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const haze1 = ctx.createRadialGradient(w*0.25, h*0.25, 0, w*0.25, h*0.25, Math.min(w,h)*0.65);
        haze1.addColorStop(0.0, 'rgba(168,160,255,0.08)');
        haze1.addColorStop(0.7, 'rgba(143,243,255,0.05)');
        haze1.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = haze1;
        ctx.fillRect(0,0,w,h);

        const haze2 = ctx.createRadialGradient(w*0.78, h*0.35, 0, w*0.78, h*0.35, Math.min(w,h)*0.62);
        haze2.addColorStop(0.0, 'rgba(143,243,255,0.06)');
        haze2.addColorStop(0.7, 'rgba(168,160,255,0.05)');
        haze2.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = haze2;
        ctx.fillRect(0,0,w,h);
        ctx.restore();
      }

      function tick(nowMs) {
        if (!running) return;
        const dt = (nowMs - lastMs) * 0.001;
        lastMs = nowMs;
        const tSec = nowMs * 0.001;

        // rotation speeds (gentle)
        star.rot  += dt * 0.18; // main rotation
        star.rot2 += dt * 0.11; // secondary drift

        updatePalette(nowMs);
        updateBloom(nowMs);

        drawBackground(tSec);
        drawStarEntity(tSec, nowMs);

        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);

      // Safety: if hidden, stop bloom state cleanly
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          star.state = 'idle';
          star.scale = 1;
        }
      });
    })();
  </script>
</body>
</html>
