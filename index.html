<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Boo Planet (v1.4)</title>

  <!-- Retro arcade font (online). If you want offline, download and self-host. -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg0:#020617;
      --bg1:#06102a;
      --bg2:#0b1d4a;

      --text:#F4F8FF;
      --muted:rgba(214,230,255,0.80);

      --glass: rgba(10, 24, 58, 0.38);
      --glass2: rgba(10, 24, 58, 0.26);
      --radius: 22px;
      --shadow: 0 24px 70px rgba(0,0,0,.55);

      --arcadeBlue1:#2aa8ff;
      --arcadeBlue2:#0a4ee6;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }

    body{
      margin:0;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background: linear-gradient(180deg, var(--bg0), var(--bg1) 55%, var(--bg2));
      overflow:hidden;
    }

    #stage{
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      touch-action:none; /* we manage dragging + taps */
    }

    .ui{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      pointer-events:none;
    }

    .panel{
      width:min(760px, 100%);
      border-radius: var(--radius);
      background:
        radial-gradient(900px 420px at 20% 12%, rgba(255,255,255,0.08), rgba(0,0,0,0) 55%),
        linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02)),
        var(--glass);
      border:1px solid rgba(255,255,255,0.12);
      box-shadow: var(--shadow);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      overflow:hidden;
      padding:22px;
      pointer-events:auto;
    }

    .screen{ display:none; }
    .screen.active{ display:block; }

    .stack{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:16px;
    }

    .titleArcade{
      font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      letter-spacing: .8px;
      text-shadow: 0 0 18px rgba(255,255,255,0.10), 0 0 36px rgba(143,243,255,0.12);
      margin:0;
      font-size: clamp(18px, 3.2vw, 30px);
      line-height: 1.25;
      text-align:center;
    }

    .copy{
      max-width: 58ch;
      margin: 0 auto;
      text-align:center;
      color: var(--muted);
      line-height: 1.65;
      font-size: 1rem;
    }
    .copy ul{
      list-style: none;
      padding: 0;
      margin: 14px auto 0;
      display: grid;
      gap: 8px;
      width: min(560px, 100%);
    }
    .copy li{
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      border-radius: 14px;
      padding: 10px 12px;
      text-align: left;
    }

    .startBtn{
      font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      letter-spacing: .8px;
      font-size: clamp(14px, 2.2vw, 18px);
      padding: 18px 22px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.14);
      cursor:pointer;
      background:
        radial-gradient(220px 100px at 20% 0%, rgba(255,255,255,0.20), rgba(0,0,0,0) 70%),
        linear-gradient(180deg, rgba(255,255,255,0.10), rgba(0,0,0,0) 42%),
        linear-gradient(180deg, var(--arcadeBlue1), var(--arcadeBlue2));
      color: rgba(244,248,255,0.98);
      text-shadow: 0 0 16px rgba(255,255,255,0.18);
      box-shadow:
        0 20px 50px rgba(0,0,0,0.42),
        0 0 0 1px rgba(255,255,255,0.10) inset,
        0 0 30px rgba(42,168,255,0.20);
      transition: transform .12s ease, filter .12s ease;
      min-width: 180px;
      -webkit-tap-highlight-color: transparent;
    }
    .startBtn:active{ transform: translateY(2px) scale(0.99); filter: brightness(0.98); }

    .hint{
      margin-top: 2px;
      font-size: 0.92rem;
      color: rgba(214,230,255,0.70);
      text-align:center;
    }

    /* Bottom center "Press to Play" */
    .pressToPlay{
      position:fixed;
      left:0;
      right:0;
      bottom: 14px;
      padding-bottom: env(safe-area-inset-bottom);
      display:none;
      pointer-events:none;
      text-align:center;
      user-select:none;

      font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: clamp(10px, 1.6vw, 13px);
      letter-spacing: .6px;
      color: rgba(244,248,255,0.78);
      text-shadow:
        0 0 18px rgba(255,255,255,0.10),
        0 0 30px rgba(143,243,255,0.10);
      opacity: 0.95;
    }

    /* Floating message overlay (fade in/out via JS) */
    .messageWrap{
      position:fixed;
      left: 12px;
      right: 12px;
      top: 12px;
      padding-top: env(safe-area-inset-top);
      display:flex;
      justify-content:center;
      pointer-events:none;
      z-index: 50;
    }
    .messageCard{
      width: min(860px, 100%);
      border-radius: 18px;
      background:
        radial-gradient(900px 420px at 30% 20%, rgba(255,255,255,0.08), rgba(0,0,0,0) 60%),
        linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)),
        var(--glass2);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      box-shadow: 0 18px 46px rgba(0,0,0,.35);
      padding: 12px 14px;
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity 520ms ease, transform 520ms ease;
    }
    .messageCard.isVisible{
      opacity: 1;
      transform: translateY(0);
    }
    .messageText{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: clamp(14px, 1.9vw, 16px);
      line-height: 1.55;
      color: rgba(244,248,255,0.90);
      text-shadow: 0 0 16px rgba(255,255,255,0.08);
      text-align:center;
      margin:0;
      white-space:pre-wrap;
    }
    .messageText strong{
      font-weight: 800;
      color: rgba(244,248,255,0.96);
    }

    /* Back button */
    .backBtn{
      position: fixed;
      left: 12px;
      top: 12px;
      margin-top: env(safe-area-inset-top);
      z-index: 70;
      display: none;
      pointer-events: auto;

      font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12px;
      letter-spacing: .6px;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      color: rgba(244,248,255,0.95);
      background:
        radial-gradient(220px 90px at 20% 0%, rgba(255,255,255,0.16), rgba(0,0,0,0) 70%),
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0) 42%),
        linear-gradient(180deg, rgba(42,168,255,0.78), rgba(10,78,230,0.78));
      box-shadow: 0 18px 40px rgba(0,0,0,0.35);
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      opacity: 0.95;
    }
    .backBtn:active{ transform: translateY(1px) scale(0.99); }

    /* ✅ Copyright (small, unobtrusive, appears on all screens) */
    .copyrightMark{
      position:fixed;
      left:0;
      right:0;
      bottom: 6px;
      padding-bottom: env(safe-area-inset-bottom);
      text-align:center;
      pointer-events:none;
      user-select:none;
      z-index: 60;

      font-size: 0.72rem;
      color: rgba(214,230,255,0.52);
      opacity: 0.92;
      letter-spacing: .2px;
      text-shadow: 0 0 14px rgba(0,0,0,0.45);
    }

    @media (prefers-reduced-motion: reduce){
      .panel, .messageCard{ backdrop-filter:none; -webkit-backdrop-filter:none; }
      .messageCard{ transition:none; }
    }
  </style>
</head>

<body>
  <canvas id="stage" aria-label="Boo Planet star stage"></canvas>

  <audio id="bgm" preload="auto" loop>
    <source src="assets/music/boo-planet.mp3" type="audio/mpeg">
  </audio>

  <!-- Message overlay -->
  <div class="messageWrap" aria-hidden="true">
    <div class="messageCard" id="messageCard">
      <p class="messageText" id="messageText"></p>
    </div>
  </div>

  <button class="backBtn" id="backBtn" type="button" aria-label="Back">BACK</button>

  <div class="ui">
    <!-- WELCOME -->
    <div class="panel screen active" id="welcome">
      <div class="stack">
        <h1 class="titleArcade">Boo Planet</h1>

        <div class="copy">
          <p><strong style="color:rgba(244,248,255,0.95);">This is a sensory cause-and-effect playground.</strong></p>
          <p>A first interaction with screens and a way for your little ones to develop without overstimulation or “wrong” inputs.</p>
          <p>Press the star to see it glow, push and pull the satellites to change their trajectory… and <strong>double tap</strong> the star to travel to Boo Planet.</p>
          <ul>
            <li><strong>Cause &amp; effect understanding</strong></li>
            <li><strong>Motor control</strong></li>
            <li><strong>Sensory processing</strong></li>
            <li><strong>Emotional safety with screens</strong></li>
          </ul>
        </div>

        <button class="startBtn" id="startBtn" type="button" aria-label="Start Boo Planet">START</button>
        <div class="hint">Tap START to begin.</div>
      </div>
    </div>

    <!-- PLAY (no center panel) -->
    <div class="screen" id="play"></div>
  </div>

  <div class="pressToPlay" id="pressToPlay">Press to Play</div>

  <!-- ✅ Copyright mark (visible across welcome + play) -->
  <div class="copyrightMark">© 2026 Boo Industries. All rights reserved.</div>

  <script>
    (() => {
      // ---------- Utilities ----------
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const lerpColor = (c1, c2, t) => ({ r: lerp(c1.r,c2.r,t), g: lerp(c1.g,c2.g,t), b: lerp(c1.b,c2.b,t) });
      const toRGBA = (c, a=1) => `rgba(${c.r|0},${c.g|0},${c.b|0},${a})`;

      const easeInOutCubic = t => (t < 0.5) ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;
      const easeOutCubic = t => 1 - Math.pow(1 - t, 3);

      const rand = (a,b)=> lerp(a,b,Math.random());
      const hypot2 = (dx,dy)=> dx*dx+dy*dy;

      // ---------- DOM ----------
      const canvas = document.getElementById('stage');
      const ctx = canvas.getContext('2d', { alpha:true });

      const bgm = document.getElementById('bgm');
      const welcome = document.getElementById('welcome');
      const play = document.getElementById('play');
      const startBtn = document.getElementById('startBtn');
      const pressToPlay = document.getElementById('pressToPlay');

      const messageCard = document.getElementById('messageCard');
      const messageText = document.getElementById('messageText');

      const backBtn = document.getElementById('backBtn');

      // ---------- Sizing ----------
      let w=0, h=0, dpr=1;

      function resize(){
        dpr = Math.min(2, window.devicePixelRatio || 1);
        w = Math.floor(window.innerWidth);
        h = Math.floor(window.innerHeight);
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        computeLayout();
        initSatellites();
        initLanterns(); // keep lanterns stable-ish on resize
      }
      window.addEventListener('resize', resize, { passive:true });

      // ---------- Background Starfield ----------
      function makeStars(count, depthMin, depthMax){
        const arr=[];
        for(let i=0;i<count;i++){
          arr.push({
            x: Math.random(),
            y: Math.random(),
            r: rand(0.6, 1.8),
            a: rand(0.22, 0.85),
            d: rand(depthMin, depthMax),
            tw: Math.random() * Math.PI * 2,
            twSp: rand(0.10, 0.32)
          });
        }
        return arr;
      }
      const starsNear = makeStars(95, 0.18, 0.35);
      const starsMid  = makeStars(150, 0.35, 0.70);
      const starsFar  = makeStars(210, 0.70, 1.15);

      function drawStarLayer(stars, t, driftX, driftY){
        for(const s of stars){
          const tw = 0.78 + 0.22 * Math.sin(s.tw + t * s.twSp);
          const x = (s.x * w + driftX * (1/s.d)) % w;
          const y = (s.y * h + driftY * (1/s.d)) % h;
          const rr = s.r * tw;

          ctx.beginPath();
          ctx.fillStyle = `rgba(255,255,255,${s.a * tw})`;
          ctx.arc(x < 0 ? x + w : x, y < 0 ? y + h : y, rr, 0, Math.PI*2);
          ctx.fill();
        }
      }

      function drawBackground(tSec){
        const g = ctx.createLinearGradient(0,0,0,h);
        g.addColorStop(0, '#020617');
        g.addColorStop(0.6, '#06102a');
        g.addColorStop(1, '#0b1d4a');
        ctx.fillStyle = g;
        ctx.fillRect(0,0,w,h);

        const driftX = Math.sin(tSec * 0.05) * 40 + Math.cos(tSec * 0.03) * 25;
        const driftY = Math.cos(tSec * 0.04) * 30 + Math.sin(tSec * 0.06) * 18;

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        drawStarLayer(starsFar,  tSec, driftX*0.25, driftY*0.25);
        drawStarLayer(starsMid,  tSec, driftX*0.55, driftY*0.55);
        drawStarLayer(starsNear, tSec, driftX*0.95, driftY*0.95);
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const haze1 = ctx.createRadialGradient(w*0.25, h*0.25, 0, w*0.25, h*0.25, Math.min(w,h)*0.65);
        haze1.addColorStop(0.0, 'rgba(168,160,255,0.08)');
        haze1.addColorStop(0.7, 'rgba(143,243,255,0.05)');
        haze1.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = haze1;
        ctx.fillRect(0,0,w,h);

        const haze2 = ctx.createRadialGradient(w*0.78, h*0.35, 0, w*0.78, h*0.35, Math.min(w,h)*0.62);
        haze2.addColorStop(0.0, 'rgba(143,243,255,0.06)');
        haze2.addColorStop(0.7, 'rgba(168,160,255,0.05)');
        haze2.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = haze2;
        ctx.fillRect(0,0,w,h);
        ctx.restore();
      }

      // ---------- Palettes ----------
      const PALETTES = [
        { core:{r:200,g:250,b:255}, plasma:{r:143,g:243,b:255}, corona:{r:168,g:160,b:255}, spark:{r:255,g:255,b:255} },
        { core:{r:255,g:240,b:210}, plasma:{r:255,g:210,b:120}, corona:{r:255,g:170,b:90},  spark:{r:255,g:255,b:255} },
        { core:{r:210,g:255,b:240}, plasma:{r:140,g:255,b:220}, corona:{r:120,g:200,b:255}, spark:{r:255,g:255,b:255} },
        { core:{r:255,g:220,b:235}, plasma:{r:255,g:170,b:210}, corona:{r:200,g:170,b:255}, spark:{r:255,g:255,b:255} },
        { core:{r:200,g:230,b:255}, plasma:{r:80,g:220,b:255},  corona:{r:120,g:150,b:255}, spark:{r:255,g:255,b:255} },
      ];

      let palette = structuredClone(PALETTES[0]);
      let paletteFrom = structuredClone(palette);
      let paletteTo = structuredClone(palette);
      let paletteTweenT0 = 0;
      let paletteTweenDur = 850;

      function pickNewPalette(nowMs){
        const next = PALETTES[Math.floor(Math.random() * PALETTES.length)];
        paletteFrom = structuredClone(palette);
        paletteTo = structuredClone(next);
        paletteTweenT0 = nowMs;
      }
      function updatePalette(nowMs){
        const t = clamp((nowMs - paletteTweenT0) / paletteTweenDur, 0, 1);
        const tt = easeOutCubic(t);
        palette = {
          core:  lerpColor(paletteFrom.core,  paletteTo.core,  tt),
          plasma:lerpColor(paletteFrom.plasma,paletteTo.plasma,tt),
          corona:lerpColor(paletteFrom.corona,paletteTo.corona,tt),
          spark: lerpColor(paletteFrom.spark, paletteTo.spark, tt)
        };
      }

      // ---------- Message overlay ----------
      let messagePlaying = false;
      let messageTimers = [];

      function clearMessageTimers(){
        for (const id of messageTimers) clearTimeout(id);
        messageTimers = [];
      }
      function setMessageVisible(isVisible){
        if (isVisible) messageCard.classList.add('isVisible');
        else messageCard.classList.remove('isVisible');
      }
      function showMessage(text){
        messageText.textContent = text;
        requestAnimationFrame(() => setMessageVisible(true));
      }
      function hideMessage(){
        setMessageVisible(false);
      }
      function showOneShot(text, totalMs=5200){
        messagePlaying = true;
        clearMessageTimers();
        const fadeMs = 600;
        const holdMs = Math.max(0, totalMs - (fadeMs*2));
        showMessage(text);
        messageTimers.push(setTimeout(() => hideMessage(), fadeMs + holdMs));
        messageTimers.push(setTimeout(() => {
          hideMessage();
          messagePlaying = false;
        }, totalMs + 20));
      }

      // ---------- Content ----------
      const UNIVERSE_MESSAGES = [
        { parts: ["Our universe is old…","The galaxy where we live, the Milky Way, is an estimated 13.6 billion years old!"] },
        { text: "Space is so big… even light, the fastest thing we know, takes time to travel." },
        { text: "Stars are very far away… the sunlight we feel is about 8 minutes old when it reaches us." },
        { text: "The Milky Way is huge… it holds hundreds of billions of stars, like a sparkling ocean." },
        { text: "We live on a celestial planet… Earth orbits our own star: The Sun." },
        { text: "Some stars are giants… many could fit our Sun inside them again and again." },
        { text: "Some stars are newborns… forming slowly inside soft clouds of cosmic dust." },
        { text: "There are many galaxies… and each one is its own great swirl of stars." },
        { text: "Space has quiet travelers… comets and asteroids drift for a long time, far from home." },
        { text: "Gravity is a gentle pull… it helps planets stay in their paths around stars." },
        { text: "We are made of star-stuff… the atoms in our bodies were once part of ancient stars." }
      ];
      let universeIndex = 0;

      const MOON_FACTS = [
        "Moon fact: Our Moon helps steady Earth’s tilt — that makes seasons more gentle and predictable.",
        "Moon fact: The Moon is moving away from Earth a tiny bit each year (about the width of a fingernail).",
        "Moon fact: Many moons are icy worlds — some may even hide oceans under their surfaces.",
        "Moon fact: Moons can shape their planets — their gravity can cause tides, waves, and even volcanoes."
      ];
      let moonFactIndex = 0;

      const HOLIDAY_MESSAGES = [
        "Festival of Lights: Many cultures celebrate light in the dark season — candles, lanterns, and warmth together.",
        "New Year’s Eve: A gentle goodbye to the old year, and a brave hello to the new.",
        "Lunar New Year: Families gather, share food, and welcome luck with bright colors and joyful sounds.",
        "Diwali: Lamps and lanterns shine to celebrate hope, goodness, and new beginnings.",
        "Hanukkah: A nightly candle reminds us that small light can last longer than we imagine.",
        "Christmas: Cozy traditions — twinkly lights, stories, kindness, and togetherness.",
        "Kwanzaa: A celebration of community, culture, and shared values through seven guiding principles.",
        "Eid: A day of gratitude, generosity, and sweet joy after a season of reflection.",
        "Holi: A celebration of color — playful, bright, and full of laughter.",
        "Mid-Autumn Festival: Mooncakes, lanterns, and looking up together at the same glowing moon.",
        "Winter Solstice: The longest night — and the turning point back toward longer days.",
        "Day of the Dead: Remembering loved ones with stories, flowers, music, and love that stays close.",
        "Vaisakhi: Songs, community meals, and bright spirit to welcome spring and new harvests.",
        "Nowruz: A fresh start at springtime — cleaning, sharing, and planting hope for the year ahead.",
        "Carnival: A joyful parade of costumes, music, and playful celebration before a quieter season.",
        "Light a Lantern: Wherever you are, a little light can be a message: “You are safe. You are loved.”"
      ];

      // ---------- Scenes ----------
      // scene = 'star' (opening play scene), 'planet' (Boo Planet + moon), 'lantern' (bigger planet + lantern swarm)
      let scene = 'star';

      function updateBackButton(){
        const show = (allowInput && (scene === 'planet' || scene === 'lantern'));
        backBtn.style.display = show ? 'block' : 'none';
      }

      // ---------- Celestial objects (Star + Boo Planet) ----------
      function makeCelestial(){
        return {
          cx:0, cy:0, rBase:0,
          rot:0, rot2:0,
          scale:1,
          intensity: 1,
          state:'idle',
          t0:0,
          bloomUpMs: 8000,
          returnMs: 2400,
          warpMs: 900
        };
      }

      const star = makeCelestial();
      const booPlanet = makeCelestial();
      const booPlanetBig = makeCelestial();

      function computeLayout(){
        const minDim = Math.min(w, h);

        // Star scene layout
        star.cx = w * 0.5;
        star.cy = h * 0.42;
        star.rBase = clamp(minDim * 0.165, 96, 190);

        // Planet scene layout
        booPlanet.cx = w * 0.5;
        booPlanet.cy = h * 0.46;
        booPlanet.rBase = clamp(minDim * 0.175, 100, 210);

        // Lantern scene layout (planet 1.7x larger than Boo Planet)
        booPlanetBig.cx = w * 0.5;
        booPlanetBig.cy = h * 0.52;
        booPlanetBig.rBase = booPlanet.rBase * 1.7;
      }

      // ---------- Satellites (only in star scene) ----------
      const satellites = [];
      const SAT_COUNT = 5;

      function initSatellites(){
        satellites.length = 0;
        for(let i=0;i<SAT_COUNT;i++){
          const baseR = star.rBase * rand(1.20, 1.95);
          const ang = Math.random() * Math.PI * 2;
          satellites.push({
            id: i,
            orbitRadius: baseR,
            angle: ang,
            omega: rand(0.10, 0.24) * (Math.random() < 0.5 ? 1 : -1),
            x: star.cx + Math.cos(ang)*baseR,
            y: star.cy + Math.sin(ang)*baseR,
            rBase: clamp(star.rBase * rand(0.12, 0.18), 16, 34),
            scale: 1,
            state: 'idle',
            t0: 0,
            swellUpMs: 900,
            returnMs: 650,
            tint: Math.random() < 0.5 ? 'cool' : 'warm',
            dragging: false
          });
        }
      }

      // ---------- Moon (planet scene) ----------
      const moon = {
        orbitR: 0,
        angle: 0,
        omega: (Math.PI * 2) / 24, // one revolution every 24 seconds
        x: 0, y: 0,
        rBase: 18,
        glow: 0
      };

      function updateMoon(dt, nowMs){
        const base = booPlanet.rBase * (scene === 'planet' ? booPlanet.scale : 1);
        moon.orbitR = clamp(base * 1.55, 120, Math.min(w,h) * 0.42);
        moon.rBase = clamp(base * 0.16, 16, 34);

        moon.angle += moon.omega * dt;
        moon.x = booPlanet.cx + Math.cos(moon.angle) * moon.orbitR;
        moon.y = booPlanet.cy + Math.sin(moon.angle) * moon.orbitR * 0.72;

        moon.glow = Math.max(0, moon.glow - dt * 1.6);
      }

      // ---------- Lanterns (lantern scene) ----------
      const LANTERN_COUNT = 16;
      const lanterns = [];
      let holidayOrder = [];
      let holidayPtr = 0;

      function shuffle(arr){
        for (let i=arr.length-1;i>0;i--){
          const j = (Math.random() * (i+1)) | 0;
          [arr[i],arr[j]] = [arr[j],arr[i]];
        }
        return arr;
      }

      function initLanterns(){
        lanterns.length = 0;
        const minDim = Math.min(w,h);
        const arenaR = clamp(minDim * 0.36, 220, 520);
        for (let i=0;i<LANTERN_COUNT;i++){
          const a = (i/LANTERN_COUNT) * Math.PI*2 + rand(-0.18, 0.18);
          const rr = arenaR * rand(0.55, 0.95);
          const x = booPlanetBig.cx + Math.cos(a) * rr;
          const y = booPlanetBig.cy + Math.sin(a) * rr * 0.68;

          lanterns.push({
            id: i,
            x, y,
            vx: rand(-55,55),
            vy: rand(-45,45),
            r: rand(16, 24),
            rot: rand(0, Math.PI*2),
            rotSp: rand(-1.4, 1.4),
            glow: 0,
            wob: rand(0, Math.PI*2),
            wobSp: rand(0.6, 1.25)
          });
        }

        holidayOrder = shuffle([...Array(HOLIDAY_MESSAGES.length)].map((_,i)=>i));
        holidayPtr = 0;
      }

      function collideLanterns(dt){
        // soft arena bounds
        const minDim = Math.min(w,h);
        const arenaR = clamp(minDim * 0.41, 260, 600);
        const cx = booPlanetBig.cx;
        const cy = booPlanetBig.cy;

        // move
        for (const p of lanterns){
          p.wob += p.wobSp * dt;
          const float = Math.sin(p.wob) * 10;

          p.x += p.vx * dt;
          p.y += p.vy * dt + float * dt * 0.10;
          p.rot += p.rotSp * dt;

          // gentle drag
          p.vx *= Math.pow(0.985, dt*60);
          p.vy *= Math.pow(0.985, dt*60);

          // keep within a soft circular arena (bounce)
          const dx = p.x - cx;
          const dy = p.y - cy;
          const dist = Math.sqrt(dx*dx + dy*dy) || 1;
          const maxDist = arenaR - p.r;
          if (dist > maxDist){
            const nx = dx / dist;
            const ny = dy / dist;
            p.x = cx + nx * maxDist;
            p.y = cy + ny * maxDist;
            const vn = p.vx*nx + p.vy*ny;
            p.vx -= (1.9 * vn) * nx;
            p.vy -= (1.9 * vn) * ny;
            p.glow = Math.max(p.glow, 0.65);
          }

          p.glow = Math.max(0, p.glow - dt * 1.2);
        }

        // pair collisions (16 => fine)
        for (let i=0;i<lanterns.length;i++){
          for (let j=i+1;j<lanterns.length;j++){
            const a = lanterns[i], b = lanterns[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const rr = a.r + b.r + 2;
            const d2 = dx*dx + dy*dy;
            if (d2 > 0 && d2 < rr*rr){
              const d = Math.sqrt(d2);
              const nx = dx / d;
              const ny = dy / d;

              // separate
              const overlap = (rr - d);
              a.x -= nx * overlap * 0.5;
              a.y -= ny * overlap * 0.5;
              b.x += nx * overlap * 0.5;
              b.y += ny * overlap * 0.5;

              // elastic-ish impulse
              const relVx = b.vx - a.vx;
              const relVy = b.vy - a.vy;
              const relN = relVx*nx + relVy*ny;
              if (relN < 0){
                const impulse = (-relN) * 0.9;
                a.vx -= impulse * nx;
                a.vy -= impulse * ny;
                b.vx += impulse * nx;
                b.vy += impulse * ny;
              }

              a.glow = Math.max(a.glow, 0.9);
              b.glow = Math.max(b.glow, 0.9);
            }
          }
        }

        // tiny “sense each other” drift (subtle cohesion)
        for (let i=0;i<lanterns.length;i++){
          const a = lanterns[i];
          let ax=0, ay=0, n=0;
          for (let j=0;j<lanterns.length;j++){
            if (i===j) continue;
            const b = lanterns[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const d2 = dx*dx + dy*dy;
            if (d2 < 160*160 && d2 > 1){
              ax += dx;
              ay += dy;
              n++;
            }
          }
          if (n){
            ax /= n; ay /= n;
            a.vx += ax * dt * 0.008;
            a.vy += ay * dt * 0.008;
          }
        }
      }

      // ---------- Calm universe messages (star scene satellites) ----------
      function playUniverseMessage(){
        if (!allowInput) return;
        if (messagePlaying) return;

        messagePlaying = true;
        clearMessageTimers();

        const msg = UNIVERSE_MESSAGES[universeIndex % UNIVERSE_MESSAGES.length];
        universeIndex++;

        const totalMs = 7500;

        if (msg.parts && Array.isArray(msg.parts) && msg.parts.length > 1){
          const parts = msg.parts.slice(0, 2);
          const partMs = Math.floor(totalMs / parts.length);
          const fadeMs = 450;

          const playPart = (text, partMs, fadeMs) => {
            const holdMs = Math.max(0, partMs - (fadeMs * 2));
            showMessage(text);
            messageTimers.push(setTimeout(() => hideMessage(), fadeMs + holdMs));
            messageTimers.push(setTimeout(() => hideMessage(), partMs));
          };

          playPart(parts[0], partMs, fadeMs);
          messageTimers.push(setTimeout(() => playPart(parts[1], partMs, fadeMs), partMs));

          messageTimers.push(setTimeout(() => {
            hideMessage();
            messagePlaying = false;
          }, partMs * parts.length + 20));

          return;
        }

        const fadeMs = 600;
        const holdMs = totalMs - (fadeMs * 2);

        showMessage(msg.text || "");
        messageTimers.push(setTimeout(() => hideMessage(), fadeMs + holdMs));
        messageTimers.push(setTimeout(() => {
          hideMessage();
          messagePlaying = false;
        }, totalMs + 20));
      }

      // ---------- Celestial drawing (shared star/planet style) ----------
      function beginShimmerClip(r, tSec){
        const steps = 84;
        ctx.beginPath();
        for (let i=0;i<=steps;i++){
          const a = (i/steps) * Math.PI*2;
          const n1 = 0.013 * Math.sin(a*3 + tSec*0.9);
          const n2 = 0.010 * Math.sin(a*7 - tSec*0.7);
          const n3 = 0.006 * Math.sin(a*11 + tSec*0.45);
          const rr = r * (1 + n1 + n2 + n3);
          const x = Math.cos(a) * rr;
          const y = Math.sin(a) * rr;
          if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.closePath();
        ctx.clip();
      }

      function drawFlaresFor(obj, r, tSec, intensity){
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.translate(obj.cx, obj.cy);

        const beamCount = 5;
        for (let i=0;i<beamCount;i++){
          const a = tSec*0.08 + i*(Math.PI*2/beamCount);
          const wob = 0.20 * Math.sin(tSec*0.35 + i*2.1);
          const ang = a + wob;

          ctx.save();
          ctx.rotate(ang);
          ctx.globalAlpha = 0.10 * intensity;

          const grad = ctx.createLinearGradient(0, 0, r*2.1, 0);
          grad.addColorStop(0.0, toRGBA(palette.corona, 0.00));
          grad.addColorStop(0.15, toRGBA(palette.corona, 0.18));
          grad.addColorStop(0.45, toRGBA(palette.plasma, 0.10));
          grad.addColorStop(1.0, 'rgba(0,0,0,0)');

          ctx.fillStyle = grad;
          ctx.filter = 'blur(1.2px)';
          ctx.beginPath();
          ctx.moveTo(r*0.35, -r*0.10);
          ctx.lineTo(r*2.05, -r*0.35);
          ctx.lineTo(r*2.05,  r*0.35);
          ctx.lineTo(r*0.35,  r*0.10);
          ctx.closePath();
          ctx.fill();

          ctx.restore();
        }
        ctx.restore();
      }

      function drawCelestial(obj, tSec, nowMs){
        const r = obj.rBase * obj.scale;
        const intensity = obj.intensity;

        // spill
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const spill = ctx.createRadialGradient(obj.cx, obj.cy, r*0.25, obj.cx, obj.cy, r*2.65);
        spill.addColorStop(0.0, toRGBA(palette.corona, 0.16 * intensity));
        spill.addColorStop(0.55, toRGBA(palette.plasma, 0.06 * intensity));
        spill.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = spill;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        drawFlaresFor(obj, r, tSec, intensity);

        // corona
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const corona = ctx.createRadialGradient(obj.cx, obj.cy, r*0.62, obj.cx, obj.cy, r*1.16);
        corona.addColorStop(0.0, toRGBA(palette.corona, 0.22 * intensity));
        corona.addColorStop(0.55, toRGBA(palette.corona, 0.12 * intensity));
        corona.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = corona;
        ctx.beginPath();
        ctx.arc(obj.cx, obj.cy, r*1.16, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        // body
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.translate(obj.cx, obj.cy);
        beginShimmerClip(r*0.80, tSec);

        const body = ctx.createRadialGradient(0,0, r*0.05, 0,0, r*0.80);
        body.addColorStop(0.0, toRGBA(palette.core, 0.96));
        body.addColorStop(0.32, toRGBA(palette.core, 0.62 * intensity));
        body.addColorStop(0.58, toRGBA(palette.plasma, 0.28 * intensity));
        body.addColorStop(0.86, toRGBA(palette.corona, 0.14 * intensity));
        body.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = body;
        ctx.fillRect(-r, -r, r*2, r*2);

        // swirls
        ctx.save();
        ctx.rotate(obj.rot);
        for (let i=0;i<20;i++){
          const a0 = (i/20) * Math.PI*2;
          const a1 = a0 + lerp(0.10, 0.34, (Math.sin(tSec*0.8 + i)+1)/2);
          const rr = lerp(r*0.16, r*0.78, (i%6)/5);
          ctx.lineWidth = lerp(2.0, 7.0, (i%5)/4);
          ctx.strokeStyle = toRGBA(palette.plasma, (0.10 + 0.08*Math.sin(tSec*0.9+i)) * intensity);
          ctx.beginPath();
          ctx.arc(0,0, rr, a0, a1);
          ctx.stroke();
        }
        ctx.restore();

        ctx.save();
        ctx.rotate(-obj.rot*1.65 + obj.rot2);
        for (let i=0;i<13;i++){
          const a0 = (i/13) * Math.PI*2;
          const a1 = a0 + lerp(0.14, 0.44, (Math.cos(tSec*0.65 + i*1.7)+1)/2);
          const rr = lerp(r*0.20, r*0.76, ((i*7)%13)/12);
          ctx.lineWidth = lerp(1.6, 5.6, (i%4)/3);
          ctx.strokeStyle = toRGBA(palette.corona, (0.08 + 0.07*Math.cos(tSec*0.8+i)) * intensity);
          ctx.beginPath();
          ctx.arc(0,0, rr, a0, a1);
          ctx.stroke();
        }
        ctx.restore();

        // spark flecks
        for (let i=0;i<22;i++){
          const ang = tSec*0.35 + i*0.62;
          const pr = r * lerp(0.08, 0.70, (Math.sin(i*12.3)+1)/2);
          const px = Math.cos(ang) * pr * 0.55;
          const py = Math.sin(ang*1.12) * pr * 0.55;

          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          ctx.fillStyle = toRGBA(palette.spark, 1);
          ctx.shadowColor = toRGBA(palette.spark, 1);
          ctx.shadowBlur = 12;
          ctx.globalAlpha = 0.12 * intensity;
          ctx.beginPath();
          ctx.arc(px, py, lerp(0.8, 2.0, (Math.cos(tSec+i)+1)/2), 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }

        ctx.restore();

        // core
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const core = ctx.createRadialGradient(obj.cx, obj.cy, r*0.02, obj.cx, obj.cy, r*0.44);
        core.addColorStop(0.0, toRGBA(palette.core, 0.98));
        core.addColorStop(0.18, toRGBA(palette.core, 0.70 * intensity));
        core.addColorStop(0.55, toRGBA(palette.plasma, 0.18 * intensity));
        core.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = core;
        ctx.beginPath();
        ctx.arc(obj.cx, obj.cy, r*0.44, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        // highlight
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const hl = ctx.createRadialGradient(obj.cx - r*0.22, obj.cy - r*0.22, r*0.03, obj.cx - r*0.22, obj.cy - r*0.22, r*0.38);
        hl.addColorStop(0.0, `rgba(255,255,255,${0.26 * intensity})`);
        hl.addColorStop(0.45, `rgba(255,255,255,${0.06 * intensity})`);
        hl.addColorStop(1.0, `rgba(255,255,255,0)`);
        ctx.fillStyle = hl;
        ctx.filter = 'blur(0.8px)';
        ctx.beginPath();
        ctx.arc(obj.cx - r*0.12, obj.cy - r*0.12, r*0.50, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // ---------- Satellites drawing ----------
      function drawSatellite(s){
        const rr = s.rBase * s.scale;
        const coolCore = { r: 210, g: 250, b: 255 };
        const coolGlow = { r: 143, g: 243, b: 255 };
        const warmCore = { r: 255, g: 240, b: 210 };
        const warmGlow = { r: 255, g: 200, b: 120 };

        const coreC = (s.tint === 'cool') ? coolCore : warmCore;
        const glowC = (s.tint === 'cool') ? coolGlow : warmGlow;

        // halo
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const halo = ctx.createRadialGradient(s.x, s.y, rr*0.25, s.x, s.y, rr*2.2);
        halo.addColorStop(0.0, toRGBA(glowC, 0.14));
        halo.addColorStop(0.55, toRGBA(glowC, 0.05));
        halo.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        // body
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const body = ctx.createRadialGradient(s.x, s.y, rr*0.03, s.x, s.y, rr*1.0);
        body.addColorStop(0.0, toRGBA(coreC, 0.92));
        body.addColorStop(0.35, toRGBA(glowC, 0.28));
        body.addColorStop(0.80, toRGBA(glowC, 0.10));
        body.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = body;
        ctx.beginPath();
        ctx.arc(s.x, s.y, rr, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        // highlight
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const hl = ctx.createRadialGradient(s.x - rr*0.25, s.y - rr*0.25, rr*0.02, s.x - rr*0.25, s.y - rr*0.25, rr*0.48);
        hl.addColorStop(0.0, 'rgba(255,255,255,0.35)');
        hl.addColorStop(0.5, 'rgba(255,255,255,0.08)');
        hl.addColorStop(1.0, 'rgba(255,255,255,0)');
        ctx.fillStyle = hl;
        ctx.filter = 'blur(0.6px)';
        ctx.beginPath();
        ctx.arc(s.x - rr*0.10, s.y - rr*0.10, rr*0.60, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // ---------- Moon drawing ----------
      function drawMoon(tSec){
        // faint orbit ring
        ctx.save();
        ctx.globalAlpha = 0.22;
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(booPlanet.cx, booPlanet.cy, moon.orbitR, moon.orbitR*0.72, 0, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();

        const rr = moon.rBase;
        const glow = 0.25 + 0.65*moon.glow;

        // halo
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const halo = ctx.createRadialGradient(moon.x, moon.y, rr*0.2, moon.x, moon.y, rr*2.8);
        halo.addColorStop(0.0, `rgba(200,240,255,${0.18*glow})`);
        halo.addColorStop(0.55, `rgba(180,220,255,${0.06*glow})`);
        halo.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        // body
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const body = ctx.createRadialGradient(moon.x, moon.y, rr*0.05, moon.x, moon.y, rr*1.1);
        body.addColorStop(0.0, 'rgba(245,250,255,0.95)');
        body.addColorStop(0.45, 'rgba(200,230,255,0.34)');
        body.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = body;
        ctx.beginPath();
        ctx.arc(moon.x, moon.y, rr, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        // tiny crater specks
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.15;
        for (let i=0;i<8;i++){
          const a = tSec*0.25 + i*0.88;
          const pr = rr * rand(0.15, 0.75);
          const px = moon.x + Math.cos(a) * pr * 0.55;
          const py = moon.y + Math.sin(a*1.12) * pr * 0.45;
          ctx.fillStyle = 'rgba(255,255,255,0.55)';
          ctx.beginPath();
          ctx.arc(px, py, rand(0.6, 1.6), 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
      }

      // ---------- Lantern drawing ----------
      function drawLantern(p, tSec){
        const rr = p.r;
        const glow = 0.18 + 0.82*p.glow;

        // outer glow
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const halo = ctx.createRadialGradient(p.x, p.y, rr*0.2, p.x, p.y, rr*3.6);
        halo.addColorStop(0.0, `rgba(255,220,160,${0.18*glow})`);
        halo.addColorStop(0.55, `rgba(255,200,120,${0.07*glow})`);
        halo.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        // lantern body (soft rounded diamond)
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);

        ctx.globalCompositeOperation = 'lighter';
        const grad = ctx.createRadialGradient(0, -rr*0.12, rr*0.1, 0, 0, rr*1.35);
        grad.addColorStop(0.0, `rgba(255,250,235,${0.92})`);
        grad.addColorStop(0.28, `rgba(255,220,160,${0.52})`);
        grad.addColorStop(0.62, `rgba(255,190,120,${0.22})`);
        grad.addColorStop(1.0, 'rgba(0,0,0,0)');

        ctx.fillStyle = grad;

        ctx.beginPath();
        ctx.moveTo(0, -rr*1.05);
        ctx.quadraticCurveTo(rr*0.95, -rr*0.35, rr*0.75, 0);
        ctx.quadraticCurveTo(rr*0.20, rr*0.95, 0, rr*1.08);
        ctx.quadraticCurveTo(-rr*0.20, rr*0.95, -rr*0.75, 0);
        ctx.quadraticCurveTo(-rr*0.95, -rr*0.35, 0, -rr*1.05);
        ctx.closePath();
        ctx.fill();

        // inner “flame”
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.55 + 0.35*Math.sin(tSec*2.2 + p.id);
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.filter = 'blur(0.4px)';
        ctx.beginPath();
        ctx.ellipse(0, rr*0.12, rr*0.22, rr*0.48, 0.2*Math.sin(tSec+p.id), 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        // little top cap
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.45;
        ctx.fillStyle = 'rgba(255,255,255,0.65)';
        ctx.beginPath();
        ctx.roundRect(-rr*0.35, -rr*1.22, rr*0.70, rr*0.26, rr*0.12);
        ctx.fill();
        ctx.restore();

        ctx.restore();
      }

      // ---------- Celestial animation states ----------
      function updateCelestialIdle(obj, nowMs){
        const t = nowMs * 0.001;
        obj.scale = 1 + 0.020 * Math.sin(t * 2 * Math.PI / 6.2);
        obj.intensity = 1.0 + 0.06 * (0.5 + 0.5*Math.sin(t * 2*Math.PI / 7.2));
      }

      function startBloom(obj, nowMs){
        pickNewPalette(nowMs);
        obj.state = 'bloomUp';
        obj.t0 = nowMs;
      }

      function startWarp(obj, nowMs){
        pickNewPalette(nowMs);
        obj.state = 'warpUp';
        obj.t0 = nowMs;
      }

      function updateCelestial(obj, nowMs, opts){
        const { bloomScale=3.0, warpScale=5.0, onWarpComplete=null } = opts || {};

        if (obj.state === 'idle'){
          updateCelestialIdle(obj, nowMs);
          return;
        }

        if (obj.state === 'bloomUp'){
          const t = clamp((nowMs - obj.t0) / obj.bloomUpMs, 0, 1);
          const e = easeInOutCubic(t);
          obj.scale = lerp(1.0, bloomScale, e);

          const quick = easeOutCubic(clamp(t / 0.10, 0, 1));
          const long = easeInOutCubic(clamp((t - 0.05) / 0.95, 0, 1));
          obj.intensity = 1.05 + 0.30 * quick + 0.90 * long;

          if (t >= 1){
            obj.state = 'return';
            obj.t0 = nowMs;
          }
          return;
        }

        if (obj.state === 'return'){
          const t = clamp((nowMs - obj.t0) / obj.returnMs, 0, 1);
          const e = easeOutCubic(t);
          obj.scale = lerp(bloomScale, 1.0, e);

          const linger = 1 - 0.35 * e;
          obj.intensity = (1.25 * linger) + 0.05;

          if (t >= 1){
            obj.state = 'idle';
            obj.t0 = nowMs;
          }
          return;
        }

        if (obj.state === 'warpUp'){
          const t = clamp((nowMs - obj.t0) / obj.warpMs, 0, 1);
          const e = easeInOutCubic(t);
          obj.scale = lerp(1.0, warpScale, e);
          obj.intensity = 1.08 + 1.15 * easeOutCubic(t);

          if (t >= 1){
            // complete transition
            obj.state = 'idle';
            obj.scale = 1;
            obj.intensity = 1;
            obj.t0 = nowMs;
            if (typeof onWarpComplete === 'function') onWarpComplete();
          }
        }
      }

      // ---------- Satellite swell ----------
      function startSatelliteSwell(s, nowMs){
        s.state = 'swellUp';
        s.t0 = nowMs;
      }
      function updateSatelliteSwell(s, nowMs){
        if (s.state === 'idle'){
          const t = nowMs * 0.001;
          s.scale = 1 + 0.010 * Math.sin(t * 2*Math.PI / (5.2 + s.id*0.6));
          return;
        }
        if (s.state === 'swellUp'){
          const t = clamp((nowMs - s.t0) / s.swellUpMs, 0, 1);
          s.scale = lerp(1.0, 1.85, easeOutCubic(t));
          if (t >= 1){
            s.state = 'return';
            s.t0 = nowMs;
          }
          return;
        }
        if (s.state === 'return'){
          const t = clamp((nowMs - s.t0) / s.returnMs, 0, 1);
          s.scale = lerp(1.85, 1.0, easeOutCubic(t));
          if (t >= 1){
            s.state = 'idle';
          }
        }
      }

      // ---------- Orbit + Drag (satellites) ----------
      function updateSatellitePositions(dt){
        for (const s of satellites){
          if (s.dragging) continue;
          s.angle += s.omega * dt;
          s.x = star.cx + Math.cos(s.angle) * s.orbitRadius;
          s.y = star.cy + Math.sin(s.angle) * s.orbitRadius;
        }
      }
      function setSatelliteOrbitFromPosition(s){
        const dx = s.x - star.cx;
        const dy = s.y - star.cy;
        const r = Math.sqrt(dx*dx + dy*dy);
        s.orbitRadius = clamp(r, star.rBase * 0.85, Math.min(w,h) * 0.48);
        s.angle = Math.atan2(dy, dx);
      }

      // ---------- Hit tests ----------
      function inHitCircle(x,y,cx,cy,r){
        const dx = x - cx;
        const dy = y - cy;
        return (dx*dx + dy*dy) <= r*r;
      }
      function hitSatellite(x,y){
        for (let i = satellites.length - 1; i >= 0; i--){
          const s = satellites[i];
          const rr = s.rBase * 1.75;
          if (inHitCircle(x,y,s.x,s.y,rr)) return i;
        }
        return -1;
      }
      function hitLantern(x,y){
        for (let i = lanterns.length - 1; i >= 0; i--){
          const p = lanterns[i];
          if (inHitCircle(x,y,p.x,p.y,p.r*1.35)) return i;
        }
        return -1;
      }

      // ---------- Interaction + double tap ----------
      let allowInput = false;
      let lastMs = performance.now();
      let tapThrottleT = 0;

      // per target double-tap tracking
      const dbl = {
        lastKey: '',
        lastT: 0,
        maxGap: 320
      };
      function isDoubleTap(key, now){
        if (dbl.lastKey === key && (now - dbl.lastT) <= dbl.maxGap){
          dbl.lastKey = '';
          dbl.lastT = 0;
          return true;
        }
        dbl.lastKey = key;
        dbl.lastT = now;
        return false;
      }

      const drag = { active:false, satIndex:-1, pointerId:null };

      canvas.addEventListener('pointerdown', (e) => {
        if (!allowInput) return;

        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);
        const now = performance.now();

        // --------- LANTERN SCENE ----------
        if (scene === 'lantern'){
          const li = hitLantern(x,y);
          if (li !== -1){
            const p = lanterns[li];
            p.glow = 1;

            // nudge on click
            p.vx += rand(-120,120);
            p.vy += rand(-90,90);

            // show next holiday message
            const idx = holidayOrder[holidayPtr % holidayOrder.length];
            holidayPtr++;
            showOneShot(HOLIDAY_MESSAGES[idx], 6400);
            return;
          }

          // double tap Boo Planet (big) to… (spec says double tap Boo Planet in planet scene)
          // keep no-op here (planet is background centerpiece).
          return;
        }

        // --------- PLANET SCENE ----------
        if (scene === 'planet'){
          // tap moon -> facts
          if (inHitCircle(x,y,moon.x,moon.y,moon.rBase*1.6)){
            moon.glow = 1;
            const fact = MOON_FACTS[moonFactIndex % MOON_FACTS.length];
            moonFactIndex++;
            showOneShot(fact, 5200);
            return;
          }

          // double tap Boo Planet -> warp to lantern scene
          const planetR = booPlanet.rBase * 1.25;
          if (inHitCircle(x,y,booPlanet.cx,booPlanet.cy,planetR)){
            const key = 'planet:boo';
            if (isDoubleTap(key, now)){
              startWarp(booPlanet, now);
              // warp complete -> lantern scene
              booPlanet.state = 'warpUp';
              booPlanet.t0 = now;
              return;
            } else {
              // optional single tap: gentle bloom
              if (booPlanet.state === 'idle') startBloom(booPlanet, now);
              return;
            }
          }
          return;
        }

        // --------- STAR SCENE ----------
        if (scene === 'star'){
          const idx = hitSatellite(x,y);
          if (idx !== -1){
            const s = satellites[idx];
            startSatelliteSwell(s, now);
            playUniverseMessage();

            // Dragging
            drag.active = true;
            drag.satIndex = idx;
            drag.pointerId = e.pointerId;
            s.dragging = true;

            s.x = x; s.y = y;
            canvas.setPointerCapture?.(e.pointerId);
            return;
          }

          const starR = star.rBase * 1.22;
          if (inHitCircle(x,y,star.cx,star.cy,starR)){
            const key = 'star:center';
            if (isDoubleTap(key, now)){
              // DOUBLE TAP: swell 5x then enter Boo Planet scene
              startWarp(star, now);
              star.state = 'warpUp';
              star.t0 = now;
              return;
            } else {
              // single tap: glow / palette
              if (star.state === 'idle') startBloom(star, now);
              if (now - tapThrottleT > 500) {
                tapThrottleT = now;
                pickNewPalette(now);
              }
              return;
            }
          }
        }
      }, { passive:false });

      canvas.addEventListener('pointermove', (e) => {
        if (!allowInput) return;
        if (scene !== 'star') return;
        if (!drag.active) return;
        if (drag.pointerId !== e.pointerId) return;

        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);

        const s = satellites[drag.satIndex];
        if (!s) return;

        s.x = x;
        s.y = y;
      }, { passive:false });

      function endDrag(e){
        if (!drag.active) return;
        if (drag.pointerId !== e.pointerId) return;

        const s = satellites[drag.satIndex];
        if (s){
          s.dragging = false;
          setSatelliteOrbitFromPosition(s);
        }

        drag.active = false;
        drag.satIndex = -1;
        drag.pointerId = null;
      }
      canvas.addEventListener('pointerup', endDrag, { passive:true });
      canvas.addEventListener('pointercancel', endDrag, { passive:true });

      // ---------- Back button ----------
      function goToScene(next){
        scene = next;
        updateBackButton();

        // clean up messages on scene change
        messagePlaying = false;
        clearMessageTimers();
        hideMessage();

        // reset double tap tracking
        dbl.lastKey = '';
        dbl.lastT = 0;

        // reset a few glows
        moon.glow = 0;
        for (const p of lanterns) p.glow = 0;

        // small hint
        if (scene === 'planet'){
          showOneShot("Welcome to Boo Planet.\nTap the moon for moon facts.\nDouble tap Boo Planet to visit the Lantern Sky.", 6200);
        } else if (scene === 'lantern'){
          showOneShot("Lantern Sky.\nTap a lantern to learn about world holidays.", 5200);
        }
      }

      backBtn.addEventListener('click', () => {
        if (!allowInput) return;
        if (scene === 'lantern') goToScene('planet');
        else if (scene === 'planet') goToScene('star');
      });

      // ---------- Welcome / Start ----------
      async function startMusic(){
        try{
          if (bgm && bgm.paused){
            bgm.volume = 0.45;
            await bgm.play();
          }
        }catch(_e){}
      }

      function setScreen(which){
        welcome.classList.toggle('active', which === 'welcome');
        play.classList.toggle('active', which === 'play');
      }

      startBtn.addEventListener('click', async () => {
        await startMusic();
        setScreen('play');
        pressToPlay.style.display = 'block';
        allowInput = true;

        scene = 'star';
        updateBackButton();
        showOneShot("Tip: Double tap the star to travel to Boo Planet.", 5200);
      });

      // ---------- Scene transitions triggered by warps ----------
      function handleWarpTransitions(nowMs){
        // star warp complete -> planet scene
        if (scene === 'star' && star.state === 'warpUp'){
          // the updateCelestial will call completion; we do it there via hook
        }
        // planet warp complete -> lantern scene
        if (scene === 'planet' && booPlanet.state === 'warpUp'){
          // handled via hook too
        }
      }

      // ---------- Main animation loop ----------
      function tick(nowMs){
        const dt = (nowMs - lastMs) * 0.001;
        lastMs = nowMs;
        const tSec = nowMs * 0.001;

        updatePalette(nowMs);
        drawBackground(tSec);

        // rotate always
        star.rot  += dt * 0.18;  star.rot2 += dt * 0.11;
        booPlanet.rot  += dt * 0.16; booPlanet.rot2 += dt * 0.10;
        booPlanetBig.rot += dt * 0.14; booPlanetBig.rot2 += dt * 0.09;

        // ---- STAR SCENE ----
        if (scene === 'star'){
          updateCelestial(star, nowMs, {
            bloomScale: 3.0,
            warpScale: 5.0,
            onWarpComplete: () => {
              // enter Boo Planet
              goToScene('planet');
            }
          });

          updateSatellitePositions(dt);
          for (const s of satellites) updateSatelliteSwell(s, nowMs);

          // satellites behind star
          for (const s of satellites) drawSatellite(s);

          // star
          drawCelestial(star, tSec, nowMs);
        }

        // ---- PLANET SCENE ----
        if (scene === 'planet'){
          updateCelestial(booPlanet, nowMs, {
            bloomScale: 2.4,
            warpScale: 5.0,
            onWarpComplete: () => {
              // enter Lantern Sky
              goToScene('lantern');
            }
          });

          updateMoon(dt, nowMs);

          // Boo Planet
          drawCelestial(booPlanet, tSec, nowMs);

          // Moon in front
          drawMoon(tSec);
        }

        // ---- LANTERN SCENE ----
        if (scene === 'lantern'){
          // big Boo Planet (idle breathing only)
          updateCelestialIdle(booPlanetBig, nowMs);
          booPlanetBig.intensity = 1.12;

          // physics lanterns
          collideLanterns(dt);

          // draw planet first
          drawCelestial(booPlanetBig, tSec, nowMs);

          // draw lanterns
          for (const p of lanterns) drawLantern(p, tSec);
        }

        updateBackButton();
        handleWarpTransitions(nowMs);

        requestAnimationFrame(tick);
      }

      // ---------- Safety ----------
      document.addEventListener('visibilitychange', () => {
        if (document.hidden){
          // reset objects
          for (const obj of [star, booPlanet, booPlanetBig]){
            obj.state = 'idle';
            obj.scale = 1;
            obj.intensity = 1;
          }

          for (const s of satellites){
            s.state = 'idle';
            s.scale = 1;
            s.dragging = false;
            setSatelliteOrbitFromPosition(s);
          }
          drag.active = false;
          drag.satIndex = -1;
          drag.pointerId = null;

          messagePlaying = false;
          clearMessageTimers();
          hideMessage();
        }
      });

      // ---------- Init ----------
      resize();
      computeLayout();
      initSatellites();
      initLanterns();
      requestAnimationFrame(tick);

      // set initial moon angle (pretty)
      moon.angle = rand(0, Math.PI*2);
      moonFactIndex = 0;
    })();
  </script>
</body>
</html>
