<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Boo Planet (v1.7.2)</title>

  <!-- Retro arcade font (online). If you want offline, download and self-host. -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg0:#020617;
      --bg1:#06102a;
      --bg2:#0b1d4a;

      --text:#F4F8FF;
      --muted:rgba(214,230,255,0.80);

      --glass: rgba(10, 24, 58, 0.38);
      --glass2: rgba(10, 24, 58, 0.26);
      --radius: 22px;
      --shadow: 0 24px 70px rgba(0,0,0,.55);

      --arcadeBlue1:#2aa8ff;
      --arcadeBlue2:#0a4ee6;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }

    body{
      margin:0;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background: linear-gradient(180deg, var(--bg0), var(--bg1) 55%, var(--bg2));
      overflow:hidden;
    }

    #stage{
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
    }

    .ui{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      pointer-events:none;
    }

    .panel{
      width:min(760px, 100%);
      border-radius: 22px;
      background:
        radial-gradient(900px 420px at 20% 12%, rgba(255,255,255,0.08), rgba(0,0,0,0) 55%),
        linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02)),
        rgba(10, 24, 58, 0.38);
      border:1px solid rgba(255,255,255,0.12);
      box-shadow: 0 24px 70px rgba(0,0,0,.55);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      overflow:hidden;
      padding:22px;
      pointer-events:auto;
    }

    .screen{ display:none; }
    .screen.active{ display:block; }

    .stack{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:16px;
    }

    .titleArcade{
      font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      letter-spacing: .8px;
      text-shadow: 0 0 18px rgba(255,255,255,0.10), 0 0 36px rgba(143,243,255,0.12);
      margin:0;
      font-size: clamp(18px, 3.2vw, 30px);
      line-height: 1.25;
      text-align:center;
    }

    .copy{
      max-width: 58ch;
      margin: 0 auto;
      text-align:center;
      color: rgba(214,230,255,0.80);
      line-height: 1.65;
      font-size: 1rem;
    }
    .copy ul{
      list-style: none;
      padding: 0;
      margin: 14px auto 0;
      display: grid;
      gap: 8px;
      width: min(560px, 100%);
    }
    .copy li{
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      border-radius: 14px;
      padding: 10px 12px;
      text-align: left;
    }

    .startBtn{
      font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      letter-spacing: .8px;
      font-size: clamp(14px, 2.2vw, 18px);
      padding: 18px 22px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.14);
      cursor:pointer;
      background:
        radial-gradient(220px 100px at 20% 0%, rgba(255,255,255,0.20), rgba(0,0,0,0) 70%),
        linear-gradient(180deg, rgba(255,255,255,0.10), rgba(0,0,0,0) 42%),
        linear-gradient(180deg, #2aa8ff, #0a4ee6);
      color: rgba(244,248,255,0.98);
      text-shadow: 0 0 16px rgba(255,255,255,0.18);
      box-shadow:
        0 20px 50px rgba(0,0,0,0.42),
        0 0 0 1px rgba(255,255,255,0.10) inset,
        0 0 30px rgba(42,168,255,0.20);
      transition: transform .12s ease, filter .12s ease;
      min-width: 180px;
      -webkit-tap-highlight-color: transparent;
    }
    .startBtn:active{ transform: translateY(2px) scale(0.99); filter: brightness(0.98); }

    .pressToPlay{
      position:fixed;
      left:0;
      right:0;
      bottom: 14px;
      padding-bottom: env(safe-area-inset-bottom);
      display:none;
      pointer-events:none;
      text-align:center;
      user-select:none;

      font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: clamp(10px, 1.6vw, 13px);
      letter-spacing: .6px;
      color: rgba(244,248,255,0.78);
      text-shadow:
        0 0 18px rgba(255,255,255,0.10),
        0 0 30px rgba(143,243,255,0.10);
      opacity: 0.95;
    }

    .messageWrap{
      position:fixed;
      left: 12px;
      right: 12px;
      top: 12px;
      padding-top: env(safe-area-inset-top);
      display:flex;
      justify-content:center;
      pointer-events:none;
      z-index: 50;
    }
    .messageCard{
      width: min(860px, 100%);
      border-radius: 18px;
      background:
        radial-gradient(900px 420px at 30% 20%, rgba(255,255,255,0.08), rgba(0,0,0,0) 60%),
        linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)),
        rgba(10, 24, 58, 0.26);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      box-shadow: 0 18px 46px rgba(0,0,0,.35);
      padding: 12px 14px;

      /* forced invisibility (left as-is per your file) */
      opacity: 0 !important;
      transform: none;
      pointer-events: none;
      transition: none;
    }
    .messageCard.isVisible{
      opacity: 0 !important;
      transform: none;
    }
    .messageText{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: clamp(14px, 1.9vw, 16px);
      line-height: 1.55;
      color: rgba(244,248,255,0.90);
      text-shadow: 0 0 16px rgba(255,255,255,0.08);
      text-align:center;
      margin:0;
      white-space:pre-wrap;
    }

    .backBtn{
      position: fixed;
      left: 12px;
      top: 12px;
      margin-top: env(safe-area-inset-top);
      z-index: 70;
      display: none;
      pointer-events: auto;

      font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12px;
      letter-spacing: .6px;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      color: rgba(244,248,255,0.95);
      background:
        radial-gradient(220px 90px at 20% 0%, rgba(255,255,255,0.16), rgba(0,0,0,0) 70%),
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0) 42%),
        linear-gradient(180deg, rgba(42,168,255,0.78), rgba(10,78,230,0.78));
      box-shadow: 0 18px 40px rgba(0,0,0,0.35);
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      opacity: 0.95;
    }
    .backBtn:active{ transform: translateY(1px) scale(0.99); }

    .copyrightMark{
      position:fixed;
      left:0;
      right:0;
      bottom: 6px;
      padding-bottom: env(safe-area-inset-bottom);
      text-align:center;
      pointer-events:none;
      user-select:none;
      z-index: 60;

      font-size: 0.72rem;
      color: rgba(214,230,255,0.52);
      opacity: 0.92;
      letter-spacing: .2px;
      text-shadow: 0 0 14px rgba(0,0,0,0.45);
    }

    @media (prefers-reduced-motion: reduce){
      .panel, .messageCard{ backdrop-filter:none; -webkit-backdrop-filter:none; }
      .messageCard{ transition:none; }
    }
  </style>
</head>

<body>
  <canvas id="stage" aria-label="Boo Planet stage"></canvas>

  <audio id="bgm" preload="auto" loop>
    <source src="assets/music/boo-planet.mp3" type="audio/mpeg">
  </audio>

  <button class="backBtn" id="backBtn" type="button" aria-label="Back">BACK</button>

  <div class="messageWrap" id="messageWrap" aria-live="polite">
    <div class="messageCard" id="messageCard">
      <p class="messageText" id="messageText"></p>
    </div>
  </div>

  <div class="ui">
    <div class="panel screen active" id="welcome">
      <div class="stack">
        <h1 class="titleArcade">Boo Planet</h1>

        <div class="copy">
          <p><strong style="color:rgba(244,248,255,0.95);">This is a sensory cause-and-effect playground.</strong></p>
          <p>A first interaction with screens and a gentle way for your little ones to develop:</p>
          <ul>
            <li><strong>Cause &amp; effect understanding</strong></li>
            <li><strong>Finer motor control</strong></li>
          </ul>
        </div>

        <button class="startBtn" id="startBtn" type="button" aria-label="Start Boo Planet">START</button>
      </div>
    </div>

    <div class="screen" id="play"></div>
  </div>

  <div class="pressToPlay" id="pressToPlay">Press the celestial bodies to play. Double-tap a satellite to enter Boo Planet.</div>
  <div class="copyrightMark">Â© 2026 Boo Industries. All rights reserved.</div>

  <script>
    (() => {
      // ---------- Utilities ----------
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const lerpColor = (c1, c2, t) => ({ r: lerp(c1.r,c2.r,t), g: lerp(c1.g,c2.g,t), b: lerp(c1.b,c2.b,t) });
      const toRGBA = (c, a=1) => `rgba(${c.r|0},${c.g|0},${c.b|0},${a})`;
      const easeInOutCubic = t => (t < 0.5) ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;
      const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
      const rand = (a,b)=> lerp(a,b,Math.random());

      function hsvToRgb(h, s, v){
        h = ((h % 360) + 360) % 360;
        s = clamp(s,0,1); v = clamp(v,0,1);
        const c = v*s;
        const x = c * (1 - Math.abs(((h/60)%2) - 1));
        const m = v - c;
        let r=0,g=0,b=0;
        if (h<60)      { r=c; g=x; b=0; }
        else if (h<120){ r=x; g=c; b=0; }
        else if (h<180){ r=0; g=c; b=x; }
        else if (h<240){ r=0; g=x; b=c; }
        else if (h<300){ r=x; g=0; b=c; }
        else           { r=c; g=0; b=x; }
        return { r: (r+m)*255, g:(g+m)*255, b:(b+m)*255 };
      }

      // ---------- DOM ----------
      const canvas = document.getElementById('stage');
      const ctx = canvas.getContext('2d', { alpha:true });

      const bgm = document.getElementById('bgm');
      const welcome = document.getElementById('welcome');
      const play = document.getElementById('play');
      const startBtn = document.getElementById('startBtn');
      const pressToPlay = document.getElementById('pressToPlay');
      const backBtn = document.getElementById('backBtn');

      const messageCard = document.getElementById('messageCard');
      const messageText = document.getElementById('messageText');

      // ---------- Sizing ----------
      let w=0, h=0, dpr=1;

      // ---------- Background Starfield ----------
      function makeStars(count, depthMin, depthMax){
        const arr=[];
        for(let i=0;i<count;i++){
          arr.push({
            x: Math.random(),
            y: Math.random(),
            r: rand(0.6, 1.8),
            a: rand(0.22, 0.85),
            d: rand(depthMin, depthMax),
            tw: Math.random() * Math.PI * 2,
            twSp: rand(0.10, 0.32)
          });
        }
        return arr;
      }
      const starsNear = makeStars(95, 0.18, 0.35);
      const starsMid  = makeStars(150, 0.35, 0.70);
      const starsFar  = makeStars(210, 0.70, 1.15);

      function drawStarLayer(stars, t, driftX, driftY){
        for(const s of stars){
          const tw = 0.78 + 0.22 * Math.sin(s.tw + t * s.twSp);
          const x = (s.x * w + driftX * (1/s.d)) % w;
          const y = (s.y * h + driftY * (1/s.d)) % h;
          const rr = s.r * tw;

          ctx.beginPath();
          ctx.fillStyle = `rgba(255,255,255,${s.a * tw})`;
          ctx.arc(x < 0 ? x + w : x, y < 0 ? y + h : y, rr, 0, Math.PI*2);
          ctx.fill();
        }
      }

      function drawBackground(tSec){
        const g = ctx.createLinearGradient(0,0,0,h);
        g.addColorStop(0, '#020617');
        g.addColorStop(0.6, '#06102a');
        g.addColorStop(1, '#0b1d4a');
        ctx.fillStyle = g;
        ctx.fillRect(0,0,w,h);

        const driftX = Math.sin(tSec * 0.05) * 40 + Math.cos(tSec * 0.03) * 25;
        const driftY = Math.cos(tSec * 0.04) * 30 + Math.sin(tSec * 0.06) * 18;

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        drawStarLayer(starsFar,  tSec, driftX*0.25, driftY*0.25);
        drawStarLayer(starsMid,  tSec, driftX*0.55, driftY*0.55);
        drawStarLayer(starsNear, tSec, driftX*0.95, driftY*0.95);
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const haze1 = ctx.createRadialGradient(w*0.25, h*0.25, 0, w*0.25, h*0.25, Math.min(w,h)*0.65);
        haze1.addColorStop(0.0, 'rgba(168,160,255,0.08)');
        haze1.addColorStop(0.7, 'rgba(143,243,255,0.05)');
        haze1.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = haze1;
        ctx.fillRect(0,0,w,h);

        const haze2 = ctx.createRadialGradient(w*0.78, h*0.35, 0, w*0.78, h*0.35, Math.min(w,h)*0.62);
        haze2.addColorStop(0.0, 'rgba(143,243,255,0.06)');
        haze2.addColorStop(0.7, 'rgba(168,160,255,0.05)');
        haze2.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = haze2;
        ctx.fillRect(0,0,w,h);
        ctx.restore();
      }

      // ---------- Palettes ----------
      const PALETTES = [
        { core:{r:200,g:250,b:255}, plasma:{r:143,g:243,b:255}, corona:{r:168,g:160,b:255}, spark:{r:255,g:255,b:255} },
        { core:{r:255,g:240,b:210}, plasma:{r:255,g:210,b:120}, corona:{r:255,g:170,b:90},  spark:{r:255,g:255,b:255} },
        { core:{r:210,g:255,b:240}, plasma:{r:140,g:255,b:220}, corona:{r:120,g:200,b:255}, spark:{r:255,g:255,b:255} },
        { core:{r:255,g:220,b:235}, plasma:{r:255,g:170,b:210}, corona:{r:200,g:170,b:255}, spark:{r:255,g:255,b:255} },
        { core:{ring:0, r:200,g:230,b:255}, plasma:{r:80,g:220,b:255},  corona:{r:120,g:150,b:255}, spark:{r:255,g:255,b:255} },
      ];

      let palette = structuredClone(PALETTES[0]);
      let paletteFrom = structuredClone(palette);
      let paletteTo = structuredClone(palette);
      let paletteTweenT0 = 0;
      let paletteTweenDur = 850;

      function pickNewPalette(nowMs){
        const next = PALETTES[Math.floor(Math.random() * PALETTES.length)];
        paletteFrom = structuredClone(palette);
        paletteTo = structuredClone(next);
        paletteTweenT0 = nowMs;
      }
      function updatePalette(nowMs){
        const t = clamp((nowMs - paletteTweenT0) / paletteTweenDur, 0, 1);
        const tt = easeOutCubic(t);
        palette = {
          core:  lerpColor(paletteFrom.core,  paletteTo.core,  tt),
          plasma:lerpColor(paletteFrom.plasma,paletteTo.plasma,tt),
          corona:lerpColor(paletteFrom.corona,paletteTo.corona,tt),
          spark: lerpColor(paletteFrom.spark, paletteTo.spark, tt)
        };
      }

      // ---------- Message overlay ----------
      let messagePlaying = false;
      let messageTimers = [];
      function clearMessageTimers(){
        for (const id of messageTimers) clearTimeout(id);
        messageTimers = [];
      }
      function setMessageVisible(isVisible){
        if (!messageCard) return;
        if (isVisible) messageCard.classList.add('isVisible');
        else messageCard.classList.remove('isVisible');
      }
      function showMessage(text){
        if (messageText) messageText.textContent = text;
        requestAnimationFrame(() => setMessageVisible(true));
      }
      function hideMessage(){ setMessageVisible(false); }
      function showOneShot(text, totalMs=5200){
        messagePlaying = true;
        clearMessageTimers();
        const fadeMs = 600;
        const holdMs = Math.max(0, totalMs - (fadeMs*2));
        showMessage(text);
        messageTimers.push(setTimeout(() => hideMessage(), fadeMs + holdMs));
        messageTimers.push(setTimeout(() => {
          hideMessage();
          messagePlaying = false;
        }, totalMs + 20));
      }

      // ---------- Scenes ----------
      const SCENES = {
        STAR: 'star',
        LANTERN: 'lantern',
        LUNAR: 'lunar',
        SUN: 'sun',
        OCEAN: 'ocean',
        GRAVITY: 'gravity',
      };

      let scene = SCENES.STAR;
      let allowInput = false;
      let sceneEnteredAt = performance.now();

      function updateBackButton(){
        const show = (allowInput && scene !== SCENES.STAR);
        backBtn.style.display = show ? 'block' : 'none';
      }

      // ---------- Transition: main body swell (6x) then fade, then swap scene ----------
      const transition = {
        active: false,
        target: SCENES.LANTERN,
        t0: 0,
        swellMs: 2000,
        fadeMs: 450,
        scaleFrom: 1,
        scaleTo: 6,
        alpha: 0,
      };

      function startSceneTransition(targetScene, nowMs){
        if (transition.active) return;
        transition.active = true;
        transition.target = targetScene;
        transition.t0 = nowMs;
        transition.alpha = 0;
        transition.scaleFrom = star.scale;
        transition.scaleTo = 6;

        allowInput = false;
        updateBackButton();
      }

      function drawFadeOverlay(alpha){
        if (alpha <= 0) return;
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = `rgba(0,0,0,${clamp(alpha,0,1)})`;
        ctx.fillRect(0,0,w,h);
        ctx.restore();
      }

      function updateTransition(nowMs){
        if (!transition.active) return;

        const t = nowMs - transition.t0;

        if (t <= transition.swellMs){
          const tt = easeInOutCubic(clamp(t / transition.swellMs, 0, 1));
          star.scale = lerp(transition.scaleFrom, transition.scaleTo, tt);
          star.intensity = 1.2 + 1.2 * easeOutCubic(tt);
          return;
        }

        const tf = t - transition.swellMs;
        const ft = clamp(tf / transition.fadeMs, 0, 1);
        transition.alpha = easeOutCubic(ft);

        if (ft >= 1){
          goToScene(transition.target, nowMs);
          transition.t0 = nowMs;
          transition.swellMs = 0;
          transition.fadeMs = 420;
          transition.alpha = 1;
          transition.active = 'fadeIn';
        }
      }

      function updateFadeIn(nowMs){
        if (transition.active !== 'fadeIn') return;
        const t = nowMs - transition.t0;
        const ft = clamp(t / transition.fadeMs, 0, 1);
        transition.alpha = 1 - easeOutCubic(ft);
        if (ft >= 1){
          transition.active = false;
          transition.alpha = 0;
          allowInput = true;
          updateBackButton();
        }
      }

      // ---------- Celestial objects ----------
      function makeCelestial(){
        return {
          cx:0, cy:0, rBase:0,
          rot:0, rot2:0,
          scale:1,
          intensity: 1,
          state:'idle',
          t0:0,
          bloomUpMs: 8000,
          returnMs: 2400,
        };
      }

      const star = makeCelestial();

      // ---------- Satellites (star hub) ----------
      const satellites = [];
      const SAT_COUNT = 5;

      const SAT_TO_SCENE = {
        0: SCENES.LANTERN,
        1: SCENES.LUNAR,
        2: SCENES.SUN,
        3: SCENES.OCEAN,
        4: SCENES.GRAVITY,
      };

      // ---------- Lanterns ----------
      const LANTERN_COUNT = 11;
      const lanterns = [];

      const SKY_LANTERN_COLORS = [
        { name:"Red",     paper:{r:255,g: 75,b: 75}, rim:{r:255,g: 55,b: 35}, honey:{r:255,g:180,b: 90}, cream:{r:255,g:245,b:230} },
        { name:"Orange",  paper:{r:255,g:140,b: 45}, rim:{r:255,g: 95,b: 25}, honey:{r:255,g:190,b:105}, cream:{r:255,g:245,b:230} },
        { name:"Yellow",  paper:{r:255,g:235,b: 95}, rim:{r:255,g:190,b: 60}, honey:{r:255,g:210,b:120}, cream:{r:255,g:252,b:238} },
        { name:"White",   paper:{r:250,g:250,b:250}, rim:{r:230,g:230,b:230}, honey:{r:255,g:220,b:150}, cream:{r:255,g:255,b:255} },
        { name:"Purple",  paper:{r:175,g:120,b:255}, rim:{r:140,g: 95,b:255}, honey:{r:255,g:205,b:135}, cream:{r:252,g:248,b:255} },
        { name:"Blue",    paper:{r: 95,g:210,b:255}, rim:{r: 55,g:150,b:255}, honey:{r:255,g:205,b:135}, cream:{r:240,g:252,b:255} },
        { name:"Lime",    paper:{r:210,g:255,b:115}, rim:{r:160,g:230,b: 75}, honey:{r:255,g:210,b:120}, cream:{r:248,g:255,b:240} },
      ];

      function bias01(power=2.0){ return Math.pow(Math.random(), power); }

      // ---------- Moon Scene ----------
      const lunar = { x:0, y:0, r:120, speed:18, glow:0 };
      const lunarComets = [];
      const lunarClouds = [];

      // ---------- Sun Scene (loop: rise 12s -> night moon traverse 8s -> rise 12s, with clouds) ----------
      const sunScene = {
        sunR: 130,
        clouds: [],
        t: 0,             // seconds since entered
        // phases:
        // A: rise 12 (0..12)
        // B: moon traverse 8 (12..20) sun down
        // C: rise 12 (20..32)
        cycle: 32
      };
      const sunMoon = { x:0, y:0, r:100, glow:0 };

      // ---------- Ocean Scene ----------
      const ocean = { lights: [], motes: [] };

      // ---------- Galactic Gravity ----------
      const gravity = { bodies: [], sats: [], drag: { active:false, satIndex:-1, pointerId:null } };

      // ---------- Layout ----------
      function computeLayout(){
        const minDim = Math.min(w, h);

        star.cx = w * 0.5;
        star.cy = h * 0.42;
        star.rBase = clamp(minDim * 0.165, 96, 190);

        lunar.r = clamp(minDim * 0.16, 90, 170);
        lunar.y = h * 0.36;

        sunScene.sunR = clamp(minDim * 0.18, 95, 185);
        sunMoon.r = clamp(minDim * 0.12, 72, 140);
        sunMoon.y = h * 0.30;
      }

      function resize(){
        dpr = Math.min(2, window.devicePixelRatio || 1);
        w = Math.floor(window.innerWidth);
        h = Math.floor(window.innerHeight);
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        computeLayout();
        initSatellites(true);
        initLanterns(true);
        initOcean(true);
        initGravity(true);
      }
      window.addEventListener('resize', resize, { passive:true });

      // ---------- Init ----------
      function initSatellites(force=false){
        if (satellites.length && !force) return;
        satellites.length = 0;
        for(let i=0;i<SAT_COUNT;i++){
          const baseR = star.rBase * rand(1.20, 1.95);
          const ang = Math.random() * Math.PI * 2;
          satellites.push({
            id: i,
            orbitRadius: baseR,
            angle: ang,
            omega: rand(0.10, 0.24) * (Math.random() < 0.5 ? 1 : -1),
            x: star.cx + Math.cos(ang)*baseR,
            y: star.cy + Math.sin(ang)*baseR,
            rBase: clamp(star.rBase * rand(0.12, 0.18), 16, 34),
            scale: 1,
            state: 'idle',
            t0: 0,
            swellUpMs: 900,
            returnMs: 650,
            tint: Math.random() < 0.5 ? 'cool' : 'warm',
            dragging: false
          });
        }
      }

      function initLanterns(force=false){
        if (lanterns.length && !force) return;
        lanterns.length = 0;

        const minX = w * 0.06;
        const maxX = w * 0.94;
        const minY = h * 0.10;
        const maxY = h * 0.88;

        for (let i=0;i<LANTERN_COUNT;i++){
          const z = clamp(0.10 + bias01(2.35) * 0.92, 0.10, 1.0);

          const yBias = lerp(0.18, 0.78, Math.pow(1 - z, 0.85));
          const y = clamp(
            lerp(minY, maxY, clamp(rand(yBias - 0.18, yBias + 0.22), 0, 1)),
            minY, maxY
          );

          const band = (Math.sin(i*0.55) * 0.08 + 0.5);
          const x = clamp(lerp(minX, maxX, clamp(rand(band - 0.25, band + 0.25), 0, 1)), minX, maxX);

          const base = clamp(Math.min(w,h) * 0.060, 22, 44);
          const scale = lerp(1.55, 0.38, z);
          const rr = base * scale * rand(0.80, 1.12);

          const colorIndex = (Math.random() * SKY_LANTERN_COLORS.length) | 0;

          lanterns.push({
            id: i,
            z,
            ax: x,
            ay: y,
            x: x + rand(-10,10) * (1 - z),
            y: y + rand(-10,10) * (1 - z),
            vx: rand(-6,6) * (1 - z),
            vy: rand(-5,5) * (1 - z),

            r: rr,
            rot: rand(-0.07, 0.07),
            wob: rand(0, Math.PI*2),
            wobSp: rand(0.28, 0.62) * lerp(1.0, 0.65, z),
            drift: rand(4, 10) * lerp(1.0, 0.55, z),
            bob: rand(2, 8) * lerp(1.0, 0.55, z),
            flick: rand(0, Math.PI*2),

            vividIndex: colorIndex,
            glow: 0
          });
        }
      }

      function initOcean(force=false){
        if (ocean.lights.length && ocean.motes.length && !force) return;

        ocean.lights.length = 0;
        ocean.motes.length = 0;

        // Firefly sprites (tap to startle)
        const lightCount = 14;
        for (let i=0;i<lightCount;i++){
          ocean.lights.push({
            x: rand(w*0.10, w*0.90),
            y: rand(h*0.62, h*0.90),
            vx: rand(-7, 7),
            vy: rand(-1.2, 1.2),
            r: rand(7, 12),
            a: rand(0.38, 0.78),
            glow: rand(0.75, 1.35),
            wob: rand(0, Math.PI*2),
            startledUntil: 0,
            homeY: 0
          });
        }
        for (const p of ocean.lights) p.homeY = p.y;

        // Undersea motes
        const moteCount = 90;
        for (let i=0;i<moteCount;i++){
          ocean.motes.push({
            x: Math.random(),
            y: Math.random(),
            r: rand(0.6, 1.6),
            a: rand(0.05, 0.16),
            vx: rand(-4, 4),
            vy: rand(-10, -3),
            tw: rand(0, Math.PI*2),
            twSp: rand(0.6, 1.4)
          });
        }
      }

      function initGravity(force=false){
        if (gravity.bodies.length && gravity.sats.length && !force) return;

        const minDim = Math.min(w,h);

        gravity.bodies = [
          { x: w*0.30, y: h*0.42, r: clamp(minDim*0.080, 38, 72), hue: rand(185, 215) },
          { x: w*0.58, y: h*0.52, r: clamp(minDim*0.095, 44, 84), hue: rand(260, 295) },
          { x: w*0.78, y: h*0.35, r: clamp(minDim*0.070, 34, 64), hue: rand(25, 55)  },
        ];

        gravity.sats.length = 0;
        const satCount = 11;
        for (let i=0;i<satCount;i++){
          const bi = (Math.random()*gravity.bodies.length)|0;
          const b = gravity.bodies[bi];
          const baseR = b.r * rand(1.6, 2.9);
          const ang = Math.random() * Math.PI * 2;
          gravity.sats.push({
            bodyIndex: bi,
            orbitRadius: baseR,
            angle: ang,
            omega: rand(0.25, 0.65) * (Math.random() < 0.5 ? 1 : -1),
            x: b.x + Math.cos(ang)*baseR,
            y: b.y + Math.sin(ang)*baseR*0.78,
            rBase: rand(10, 16),
            dragging: false,
            glow: 0,
            hue: (b.hue + rand(-25, 25))
          });
        }
      }

      function resetSunScene(nowMs){
        sunScene.t = 0;
        sunScene.clouds.length = 0;
        sunMoon.x = w + sunMoon.r*1.2;
        sunMoon.glow = 0;
      }

      function resetLunarScene(nowMs){
        lunarComets.length = 0;
        lunarClouds.length = 0;
      }

      // ---------- Drawing helpers (celestial) ----------
      function beginShimmerClip(r, tSec){
        const steps = 84;
        ctx.beginPath();
        for (let i=0;i<=steps;i++){
          const a = (i/steps) * Math.PI*2;
          const n1 = 0.013 * Math.sin(a*3 + tSec*0.9);
          const n2 = 0.010 * Math.sin(a*7 - tSec*0.7);
          const n3 = 0.006 * Math.sin(a*11 + tSec*0.45);
          const rr = r * (1 + n1 + n2 + n3);
          const x = Math.cos(a) * rr;
          const y = Math.sin(a) * rr;
          if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.closePath();
        ctx.clip();
      }

      function drawFlaresFor(obj, r, tSec, intensity){
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.translate(obj.cx, obj.cy);

        const beamCount = 5;
        for (let i=0;i<beamCount;i++){
          const a = tSec*0.08 + i*(Math.PI*2/beamCount);
          const wob = 0.20 * Math.sin(tSec*0.35 + i*2.1);
          const ang = a + wob;

          ctx.save();
          ctx.rotate(ang);
          ctx.globalAlpha = 0.10 * intensity;

          const grad = ctx.createLinearGradient(0, 0, r*2.1, 0);
          grad.addColorStop(0.0, toRGBA(palette.corona, 0.00));
          grad.addColorStop(0.15, toRGBA(palette.corona, 0.18));
          grad.addColorStop(0.45, toRGBA(palette.plasma, 0.10));
          grad.addColorStop(1.0, 'rgba(0,0,0,0)');

          ctx.fillStyle = grad;
          ctx.filter = 'blur(1.2px)';
          ctx.beginPath();
          ctx.moveTo(r*0.35, -r*0.10);
          ctx.lineTo(r*2.05, -r*0.35);
          ctx.lineTo(r*2.05,  r*0.35);
          ctx.lineTo(r*0.35,  r*0.10);
          ctx.closePath();
          ctx.fill();

          ctx.restore();
        }
        ctx.restore();
      }

      function drawCelestial(obj, tSec){
        const r = obj.rBase * obj.scale;
        const intensity = obj.intensity;

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const spill = ctx.createRadialGradient(obj.cx, obj.cy, r*0.25, obj.cx, obj.cy, r*2.65);
        spill.addColorStop(0.0, toRGBA(palette.corona, 0.16 * intensity));
        spill.addColorStop(0.55, toRGBA(palette.plasma, 0.06 * intensity));
        spill.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = spill;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        drawFlaresFor(obj, r, tSec, intensity);

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const corona = ctx.createRadialGradient(obj.cx, obj.cy, r*0.62, obj.cx, obj.cy, r*1.16);
        corona.addColorStop(0.0, toRGBA(palette.corona, 0.22 * intensity));
        corona.addColorStop(0.55, toRGBA(palette.corona, 0.12 * intensity));
        corona.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = corona;
        ctx.beginPath();
        ctx.arc(obj.cx, obj.cy, r*1.16, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.translate(obj.cx, obj.cy);
        beginShimmerClip(r*0.80, tSec);

        const body = ctx.createRadialGradient(0,0, r*0.05, 0,0, r*0.80);
        body.addColorStop(0.0, toRGBA(palette.core, 0.96));
        body.addColorStop(0.32, toRGBA(palette.core, 0.62 * intensity));
        body.addColorStop(0.58, toRGBA(palette.plasma, 0.28 * intensity));
        body.addColorStop(0.86, toRGBA(palette.corona, 0.14 * intensity));
        body.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = body;
        ctx.fillRect(-r, -r, r*2, r*2);

        ctx.save();
        ctx.rotate(obj.rot);
        for (let i=0;i<20;i++){
          const a0 = (i/20) * Math.PI*2;
          const a1 = a0 + lerp(0.10, 0.34, (Math.sin(tSec*0.8 + i)+1)/2);
          const rr = lerp(r*0.16, r*0.78, (i%6)/5);
          ctx.lineWidth = lerp(2.0, 7.0, (i%5)/4);
          ctx.strokeStyle = toRGBA(palette.plasma, (0.10 + 0.08*Math.sin(tSec*0.9+i)) * intensity);
          ctx.beginPath();
          ctx.arc(0,0, rr, a0, a1);
          ctx.stroke();
        }
        ctx.restore();

        ctx.save();
        ctx.rotate(-obj.rot*1.65 + obj.rot2);
        for (let i=0;i<13;i++){
          const a0 = (i/13) * Math.PI*2;
          const a1 = a0 + lerp(0.14, 0.44, (Math.cos(tSec*0.65 + i*1.7)+1)/2);
          const rr = lerp(r*0.20, r*0.76, ((i*7)%13)/12);
          ctx.lineWidth = lerp(1.6, 5.6, (i%4)/3);
          ctx.strokeStyle = toRGBA(palette.corona, (0.08 + 0.07*Math.cos(tSec*0.8+i)) * intensity);
          ctx.beginPath();
          ctx.arc(0,0, rr, a0, a1);
          ctx.stroke();
        }
        ctx.restore();

        for (let i=0;i<22;i++){
          const ang = tSec*0.35 + i*0.62;
          const pr = r * lerp(0.08, 0.70, (Math.sin(i*12.3)+1)/2);
          const px = Math.cos(ang) * pr * 0.55;
          const py = Math.sin(ang*1.12) * pr * 0.55;

          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          ctx.fillStyle = toRGBA(palette.spark, 1);
          ctx.shadowColor = toRGBA(palette.spark, 1);
          ctx.shadowBlur = 12;
          ctx.globalAlpha = 0.12 * intensity;
          ctx.beginPath();
          ctx.arc(px, py, lerp(0.8, 2.0, (Math.cos(tSec+i)+1)/2), 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }

        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const core = ctx.createRadialGradient(obj.cx, obj.cy, r*0.02, obj.cx, obj.cy, r*0.44);
        core.addColorStop(0.0, toRGBA(palette.core, 0.98));
        core.addColorStop(0.18, toRGBA(palette.core, 0.70 * intensity));
        core.addColorStop(0.55, toRGBA(palette.plasma, 0.18 * intensity));
        core.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = core;
        ctx.beginPath();
        ctx.arc(obj.cx, obj.cy, r*0.44, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const hl = ctx.createRadialGradient(obj.cx - r*0.22, obj.cy - r*0.22, r*0.03, obj.cx - r*0.22, obj.cy - r*0.22, r*0.38);
        hl.addColorStop(0.0, `rgba(255,255,255,${0.26 * intensity})`);
        hl.addColorStop(0.45, `rgba(255,255,255,${0.06 * intensity})`);
        hl.addColorStop(1.0, `rgba(255,255,255,0)`);
        ctx.fillStyle = hl;
        ctx.filter = 'blur(0.8px)';
        ctx.beginPath();
        ctx.arc(obj.cx - r*0.12, obj.cy - r*0.12, r*0.50, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // ---------- Satellites ----------
      function drawSatellite(s){
        const rr = s.rBase * s.scale;
        const coolCore = { r: 210, g: 250, b: 255 };
        const coolGlow = { r: 143, g: 243, b: 255 };
        const warmCore = { r: 255, g: 240, b: 210 };
        const warmGlow = { r: 255, g: 200, b: 120 };

        const coreC = (s.tint === 'cool') ? coolCore : warmCore;
        const glowC = (s.tint === 'cool') ? coolGlow : warmGlow;

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const halo = ctx.createRadialGradient(s.x, s.y, rr*0.25, s.x, s.y, rr*2.2);
        halo.addColorStop(0.0, toRGBA(glowC, 0.14));
        halo.addColorStop(0.55, toRGBA(glowC, 0.05));
        halo.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const body = ctx.createRadialGradient(s.x, s.y, rr*0.03, s.x, s.y, rr*1.0);
        body.addColorStop(0.0, toRGBA(coreC, 0.92));
        body.addColorStop(0.35, toRGBA(glowC, 0.28));
        body.addColorStop(0.80, toRGBA(glowC, 0.10));
        body.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = body;
        ctx.beginPath();
        ctx.arc(s.x, s.y, rr, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const hl = ctx.createRadialGradient(s.x - rr*0.25, s.y - rr*0.25, rr*0.02, s.x - rr*0.25, s.y - rr*0.25, rr*0.48);
        hl.addColorStop(0.0, 'rgba(255,255,255,0.35)');
        hl.addColorStop(0.5, 'rgba(255,255,255,0.08)');
        hl.addColorStop(1.0, 'rgba(255,255,255,0)');
        ctx.fillStyle = hl;
        ctx.filter = 'blur(0.6px)';
        ctx.beginPath();
        ctx.arc(s.x - rr*0.10, s.y - rr*0.10, rr*0.60, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // ---------- Lantern motion + draw ----------
      function updateLanterns(dt, tSec){
        const padX = 22;
        const minX = padX;
        const maxX = w - padX;
        const minY = h*0.08;
        const maxY = h*0.90;

        const baseWindX = Math.sin(tSec*0.10) * 10 + Math.cos(tSec*0.06) * 6;
        const baseWindY = Math.cos(tSec*0.09) * 3;

        for (const p of lanterns){
          p.wob += p.wobSp * dt;
          p.flick += (1.9 + p.wobSp) * dt;

          const par = lerp(1.0, 0.35, p.z);

          const ox = (Math.sin(p.wob + p.id*0.7) * p.drift + Math.cos(p.wob*0.63) * (p.drift*0.55)) * par;
          const oy = (Math.cos(p.wob*1.12 + p.id*0.4) * p.bob) * par;

          const windX = baseWindX * par;
          const windY = baseWindY * par;

          const tx = p.ax + ox + windX;
          const ty = p.ay + oy + windY;

          const dx = tx - p.x;
          const dy = ty - p.y;

          const spring = 0.95;
          p.vx += dx * spring * dt;
          p.vy += dy * spring * dt;

          p.x += p.vx * dt;
          p.y += p.vy * dt;

          const damp = Math.pow(0.985, dt*60);
          p.vx *= damp;
          p.vy *= damp;

          p.rot = (Math.sin(p.wob*0.7 + p.id) * 0.06) * lerp(1.0, 0.45, p.z);

          if (p.x < minX){ p.x = minX; p.vx *= -0.20; p.ax += 8; }
          if (p.x > maxX){ p.x = maxX; p.vx *= -0.20; p.ax -= 8; }
          if (p.y < minY){ p.y = minY; p.vy *= -0.20; p.ay += 8; }
          if (p.y > maxY){ p.y = maxY; p.vy *= -0.20; p.ay -= 8; }

          p.ax = clamp(p.ax, minX+18, maxX-18);
          p.ay = clamp(p.ay, minY+18, maxY-18);

          p.glow = Math.max(0, p.glow - dt * 0.90);
        }
      }

      function drawLantern(p, tSec){
        const rr = p.r;
        const pal = SKY_LANTERN_COLORS[p.vividIndex % SKY_LANTERN_COLORS.length];

        const flick = 0.78 + 0.22*Math.sin(p.flick);
        const glowUp = 0.18 + 0.82*p.glow;
        const glow = clamp(flick * (0.65 + glowUp), 0.25, 1.55);

        const z = p.z;
        const alphaDepth = lerp(1.00, 0.55, z);
        const blurPx = lerp(0.0, 1.4, z);

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = alphaDepth;

        const halo = ctx.createRadialGradient(p.x, p.y, rr*0.2, p.x, p.y, rr*5.2);
        halo.addColorStop(0.0, `rgba(${pal.honey.r},${pal.honey.g},${pal.honey.b},${0.20*glow})`);
        halo.addColorStop(0.38, `rgba(${pal.rim.r},${pal.rim.g},${pal.rim.b},${0.12*glow})`);
        halo.addColorStop(0.78, `rgba(${pal.rim.r},${pal.rim.g},${pal.rim.b},${0.05*glow})`);
        halo.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.globalAlpha = alphaDepth;

        const bw = rr * 1.30;
        const bh = rr * 1.85;
        const topW = bw * 0.88;
        const botW = bw * 1.02;

        function lanternPath(){
          const rCorner = rr * 0.22;
          const yTop = -bh*0.62;
          const yBot =  bh*0.58;

          ctx.beginPath();
          ctx.moveTo(-topW*0.5 + rCorner, yTop);
          ctx.lineTo( topW*0.5 - rCorner, yTop);
          ctx.quadraticCurveTo( topW*0.5, yTop, topW*0.5, yTop + rCorner);

          ctx.lineTo( botW*0.5, yBot - rCorner);
          ctx.quadraticCurveTo( botW*0.5, yBot, botW*0.5 - rCorner, yBot);

          ctx.lineTo(-botW*0.5 + rCorner, yBot);
          ctx.quadraticCurveTo(-botW*0.5, yBot, -botW*0.5, yBot - rCorner);

          ctx.lineTo(-topW*0.5, yTop + rCorner);
          ctx.quadraticCurveTo(-topW*0.5, yTop, -topW*0.5 + rCorner, yTop);

          ctx.closePath();
        }

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.filter = blurPx ? `blur(${blurPx}px)` : 'none';

        const paper = ctx.createRadialGradient(0, bh*0.10, rr*0.08, 0, bh*0.18, rr*2.25);
        paper.addColorStop(0.0, `rgba(${pal.cream.r},${pal.cream.g},${pal.cream.b},${0.92})`);
        paper.addColorStop(0.20, `rgba(${pal.honey.r},${pal.honey.g},${pal.honey.b},${0.78})`);
        paper.addColorStop(0.55, `rgba(${pal.paper.r},${pal.paper.g},${pal.paper.b},${0.52})`);
        paper.addColorStop(0.88, `rgba(${pal.rim.r},${pal.rim.g},${pal.rim.b},${0.22})`);
        paper.addColorStop(1.0, 'rgba(0,0,0,0)');

        ctx.fillStyle = paper;
        lanternPath();
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.12 + 0.10*(0.18 + 0.82*p.glow);
        ctx.strokeStyle = `rgba(255,255,255,0.30)`;
        ctx.lineWidth = Math.max(1, rr*0.04);
        ctx.filter = blurPx ? `blur(${blurPx*0.6}px)` : 'none';
        lanternPath();
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.filter = blurPx ? `blur(${blurPx*0.7}px)` : 'none';
        const baseHalo = ctx.createRadialGradient(0, bh*0.46, rr*0.10, 0, bh*0.50, rr*1.45);
        baseHalo.addColorStop(0.0, `rgba(255,255,255,${0.42*glow})`);
        baseHalo.addColorStop(0.30, `rgba(${pal.honey.r},${pal.honey.g},${pal.honey.b},${0.34*glow})`);
        baseHalo.addColorStop(0.70, `rgba(${pal.rim.r},${pal.rim.g},${pal.rim.b},${0.14*glow})`);
        baseHalo.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = baseHalo;
        ctx.beginPath();
        ctx.ellipse(0, bh*0.52, bw*0.34, rr*0.22, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        ctx.restore();
      }

      function drawLanternSkyOverlays(){
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const sky = ctx.createRadialGradient(w*0.52, h*0.32, 0, w*0.52, h*0.42, Math.min(w,h)*0.95);
        sky.addColorStop(0.0, 'rgba(255,190,120,0.065)');
        sky.addColorStop(0.55, 'rgba(255,160,90,0.03)');
        sky.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = sky;
        ctx.fillRect(0,0,w,h);

        ctx.globalCompositeOperation = 'multiply';
        const vig = ctx.createRadialGradient(w*0.5, h*0.45, Math.min(w,h)*0.20, w*0.5, h*0.45, Math.min(w,h)*0.78);
        vig.addColorStop(0.0, 'rgba(0,0,0,0)');
        vig.addColorStop(0.75, 'rgba(0,0,0,0.18)');
        vig.addColorStop(1.0, 'rgba(0,0,0,0.34)');
        ctx.fillStyle = vig;
        ctx.fillRect(0,0,w,h);
        ctx.restore();
      }

      // ---------- Celestial animation ----------
      function updateCelestialIdle(obj, nowMs){
        const t = nowMs * 0.001;
        obj.scale = 1 + 0.020 * Math.sin(t * 2 * Math.PI / 6.2);
        obj.intensity = 1.0 + 0.06 * (0.5 + 0.5*Math.sin(t * 2*Math.PI / 7.2));
      }
      function startBloom(obj, nowMs){
        pickNewPalette(nowMs);
        obj.state = 'bloomUp';
        obj.t0 = nowMs;
      }
      function updateCelestial(obj, nowMs, opts){
        const { bloomScale=3.0 } = opts || {};
        if (obj.state === 'idle'){
          updateCelestialIdle(obj, nowMs);
          return;
        }

        if (obj.state === 'bloomUp'){
          const t = clamp((nowMs - obj.t0) / obj.bloomUpMs, 0, 1);
          const e = easeInOutCubic(t);
          obj.scale = lerp(1.0, bloomScale, e);

          const quick = easeOutCubic(clamp(t / 0.10, 0, 1));
          const long = easeInOutCubic(clamp((t - 0.05) / 0.95, 0, 1));
          obj.intensity = 1.05 + 0.30 * quick + 0.90 * long;

          if (t >= 1){
            obj.state = 'return';
            obj.t0 = nowMs;
          }
          return;
        }

        if (obj.state === 'return'){
          const t = clamp((nowMs - obj.t0) / obj.returnMs, 0, 1);
          const e = easeOutCubic(t);
          obj.scale = lerp(bloomScale, 1.0, e);

          const linger = 1 - 0.35 * e;
          obj.intensity = (1.25 * linger) + 0.05;

          if (t >= 1){
            obj.state = 'idle';
            obj.t0 = nowMs;
          }
        }
      }

      // ---------- Satellite motion ----------
      function updateSatellitePositions(dt){
        for (const s of satellites){
          if (s.dragging) continue;
          s.angle += s.omega * dt;
          s.x = star.cx + Math.cos(s.angle) * s.orbitRadius;
          s.y = star.cy + Math.sin(s.angle) * s.orbitRadius;
        }
      }
      function setSatelliteOrbitFromPosition(s){
        const dx = s.x - star.cx;
        const dy = s.y - star.cy;
        const r = Math.sqrt(dx*dx + dy*dy);
        s.orbitRadius = clamp(r, star.rBase * 0.85, Math.min(w,h) * 0.48);
        s.angle = Math.atan2(dy, dx);
      }
      function startSatelliteSwell(s, nowMs){
        s.state = 'swellUp';
        s.t0 = nowMs;
      }
      function updateSatelliteSwell(s, nowMs){
        if (s.state === 'idle'){
          const t = nowMs * 0.001;
          s.scale = 1 + 0.010 * Math.sin(t * 2*Math.PI / (5.2 + s.id*0.6));
          return;
        }
        if (s.state === 'swellUp'){
          const t = clamp((nowMs - s.t0) / s.swellUpMs, 0, 1);
          s.scale = lerp(1.0, 1.85, easeOutCubic(t));
          if (t >= 1){
            s.state = 'return';
            s.t0 = nowMs;
          }
          return;
        }
        if (s.state === 'return'){
          const t = clamp((nowMs - s.t0) / s.returnMs, 0, 1);
          s.scale = lerp(1.85, 1.0, easeOutCubic(t));
          if (t >= 1) s.state = 'idle';
        }
      }

      // ---------- Hit tests ----------
      function inHitCircle(x,y,cx,cy,r){
        const dx = x - cx, dy = y - cy;
        return (dx*dx + dy*dy) <= r*r;
      }
      function hitSatellite(x,y){
        for (let i = satellites.length - 1; i >= 0; i--){
          const s = satellites[i];
          const rr = s.rBase * 1.75;
          if (inHitCircle(x,y,s.x,s.y,rr)) return i;
        }
        return -1;
      }
      function hitLantern(x,y){
        for (let i = lanterns.length - 1; i >= 0; i--){
          const p = lanterns[i];
          if (inHitCircle(x,y,p.x,p.y,p.r*1.05)) return i;
        }
        return -1;
      }
      function hitLunarMoon(x,y){
        return inHitCircle(x,y,lunar.x,lunar.y,lunar.r*0.92);
      }
      function hitOceanLight(x,y){
        for (let i=ocean.lights.length-1; i>=0; i--){
          const p = ocean.lights[i];
          if (inHitCircle(x,y,p.x,p.y,p.r*1.9)) return i;
        }
        return -1;
      }
      function hitGravitySat(x,y){
        for (let i = gravity.sats.length - 1; i >= 0; i--){
          const s = gravity.sats[i];
          if (inHitCircle(x,y,s.x,s.y,s.rBase*2.1)) return i;
        }
        return -1;
      }

      // ---------- Double tap ----------
      const dbl = { lastKey:'', lastT:0, maxGap:360 };
      function isDoubleTap(key, now){
        if (dbl.lastKey === key && (now - dbl.lastT) <= dbl.maxGap){
          dbl.lastKey = '';
          dbl.lastT = 0;
          return true;
        }
        dbl.lastKey = key;
        dbl.lastT = now;
        return false;
      }

      // ---------- Drag ----------
      const drag = { active:false, satIndex:-1, pointerId:null };

      // ---------- Scene navigation ----------
      function resetPerSceneState(next, nowMs){
        sceneEnteredAt = nowMs;

        star.state = 'idle';
        star.scale = 1;
        star.intensity = 1;

        if (next === SCENES.LUNAR){
          lunar.x = -lunar.r * 1.25;
          lunar.glow = 0;
          resetLunarScene(nowMs);
        }

        if (next === SCENES.SUN){
          resetSunScene(nowMs);
        }

        if (next === SCENES.OCEAN){
          initOcean(false);
        }

        if (next === SCENES.GRAVITY){
          initGravity(false);
          gravity.drag.active = false;
          gravity.drag.satIndex = -1;
          gravity.drag.pointerId = null;
          for (const s of gravity.sats){ s.dragging = false; s.glow = 0; }
        }
      }

      function goToScene(next, nowMs=performance.now()){
        scene = next;
        resetPerSceneState(next, nowMs);
        updateBackButton();

        messagePlaying = false;
        clearMessageTimers();
        hideMessage();

        dbl.lastKey = '';
        dbl.lastT = 0;

        if (scene === SCENES.STAR){
          showOneShot("Tip: Double tap a satellite to enter Boo Planet.", 5200);
        }
      }

      backBtn.addEventListener('click', () => {
        if (!allowInput) return;
        goToScene(SCENES.STAR, performance.now());
      });

      // ---------- Ocean aesthetic helpers ----------
      function drawUnderseaBackdrop(tSec){
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        const g = ctx.createLinearGradient(0,0,0,h);
        g.addColorStop(0.0, 'rgba(10, 55, 80, 0.55)');
        g.addColorStop(0.35, 'rgba(6, 40, 70, 0.65)');
        g.addColorStop(0.75, 'rgba(3, 20, 45, 0.78)');
        g.addColorStop(1.0, 'rgba(2, 8, 22, 0.90)');
        ctx.fillStyle = g;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.18;
        const rayCount = 6;
        for (let i=0;i<rayCount;i++){
          const x = w*(0.15 + 0.70*(i/(rayCount-1))) + Math.sin(tSec*0.12 + i*1.7)*18;
          const y = h*0.05 + Math.cos(tSec*0.10 + i)*10;
          const r1 = Math.min(w,h) * 0.95;

          const rg = ctx.createRadialGradient(x, y, 0, x, y, r1);
          rg.addColorStop(0.00, 'rgba(210,250,255,0.28)');
          rg.addColorStop(0.22, 'rgba(170,235,255,0.14)');
          rg.addColorStop(0.58, 'rgba(120,200,255,0.06)');
          rg.addColorStop(1.00, 'rgba(0,0,0,0)');

          ctx.filter = 'blur(18px)';
          ctx.fillStyle = rg;
          ctx.fillRect(0,0,w,h);
        }
        ctx.filter = 'none';
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.22;
        ctx.filter = 'blur(8px)';

        const cell = 110;
        for (let y=0; y<=h+cell; y+=cell){
          for (let x=0; x<=w+cell; x+=cell){
            const nx = x / w;
            const ny = y / h;

            const p1 = Math.sin(nx*10.0 + tSec*0.55) * Math.cos(ny*12.0 - tSec*0.42);
            const p2 = Math.cos(nx*7.0  - tSec*0.33) * Math.sin(ny*9.0  + tSec*0.60);
            const p3 = Math.sin((nx+ny)*11.0 + tSec*0.25);
            const v = (p1 + p2 + 0.7*p3) / 2.7;

            const depthFade = clamp(1 - Math.pow(ny, 1.25), 0, 1);
            const a = clamp((v*0.55 + 0.45), 0, 1) * depthFade;

            if (a < 0.08) continue;

            const rr = cell * (0.55 + 0.55*a);
            const cg = ctx.createRadialGradient(x, y, rr*0.05, x, y, rr);
            cg.addColorStop(0.0, `rgba(210,255,255,${0.18*a})`);
            cg.addColorStop(0.5, `rgba(140,230,255,${0.10*a})`);
            cg.addColorStop(1.0, 'rgba(0,0,0,0)');
            ctx.fillStyle = cg;
            ctx.fillRect(x-rr, y-rr, rr*2, rr*2);
          }
        }
        ctx.filter = 'none';
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        const fog = ctx.createLinearGradient(0,0,0,h);
        fog.addColorStop(0.0, 'rgba(255,255,255,0.02)');
        fog.addColorStop(0.35, 'rgba(180,240,255,0.05)');
        fog.addColorStop(0.70, 'rgba(30,80,120,0.10)');
        fog.addColorStop(1.0, 'rgba(0,0,0,0.20)');
        ctx.fillStyle = fog;
        ctx.fillRect(0,0,w,h);
        ctx.restore();
      }

      function updateAndDrawOcean(dt, tSec, nowMs){
        initOcean(false);

        drawUnderseaBackdrop(tSec);

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const surf = ctx.createRadialGradient(w*0.52, h*0.02, 0, w*0.52, h*0.02, Math.min(w,h)*0.85);
        surf.addColorStop(0.00, 'rgba(225,255,255,0.22)');
        surf.addColorStop(0.30, 'rgba(160,240,255,0.10)');
        surf.addColorStop(1.00, 'rgba(0,0,0,0)');
        ctx.filter = 'blur(10px)';
        ctx.fillStyle = surf;
        ctx.fillRect(0,0,w,h);
        ctx.filter = 'none';
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        for (const m of ocean.motes){
          m.tw += m.twSp * dt;
          const tw = 0.75 + 0.25 * Math.sin(m.tw);

          m.x = (m.x + (m.vx * dt) / w);
          m.y = (m.y + (m.vy * dt) / h);

          if (m.x < -0.05) m.x = 1.05;
          if (m.x > 1.05)  m.x = -0.05;
          if (m.y < -0.05) m.y = 1.05;
          if (m.y > 1.05)  m.y = -0.05;

          const px = m.x * w;
          const py = m.y * h;

          const depth = clamp(1 - Math.abs(m.y - 0.45) * 1.2, 0, 1);
          ctx.fillStyle = `rgba(220,250,255,${m.a * tw * depth})`;
          ctx.beginPath();
          ctx.arc(px, py, m.r * tw, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();

        // Firefly sprites (tap startled)
        for (const p of ocean.lights){
          p.wob += dt * 1.2;

          const startled = nowMs < p.startledUntil;

          // Base drift
          p.x += p.vx * dt;
          p.y += p.vy * dt + Math.sin(p.wob) * 0.25;

          // If startled: add jitter and stronger upward pull for a moment
          if (startled){
            p.x += Math.sin(p.wob*8.5 + p.x*0.01) * 18 * dt;
            p.y += -rand(30, 60) * dt;
          } else {
            // gently return toward original band (feels calmer)
            const targetY = p.homeY;
            p.y += (targetY - p.y) * (dt * 0.20);
          }

          // wrap
          if (p.x < -60) p.x = w + 60;
          if (p.x > w + 60) p.x = -60;

          // keep in lower half; allow startled to shoot upward a bit
          const yMin = h*0.40;
          const yMax = h*0.90;
          p.y = clamp(p.y, yMin, yMax);

          const flick = 0.78 + 0.22*Math.sin(p.wob*1.9);
          const rr = p.r;

          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          ctx.globalAlpha = 0.85 * p.a;
          ctx.filter = 'blur(6px)';
          const halo = ctx.createRadialGradient(p.x, p.y, rr*0.12, p.x, p.y, rr*7.0);
          halo.addColorStop(0.0, `rgba(255,235,190,${0.22*p.glow*flick})`);
          halo.addColorStop(0.35, `rgba(255,190,140,${0.13*p.glow*flick})`);
          halo.addColorStop(0.70, `rgba(170,230,255,${0.06*p.glow*flick})`);
          halo.addColorStop(1.0, 'rgba(0,0,0,0)');
          ctx.fillStyle = halo;
          ctx.fillRect(0,0,w,h);
          ctx.filter = 'none';
          ctx.restore();

          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          const core = ctx.createRadialGradient(p.x, p.y, rr*0.02, p.x, p.y, rr*1.15);
          core.addColorStop(0.0, `rgba(255,255,255,${0.82*p.a})`);
          core.addColorStop(0.25, `rgba(255,245,220,${0.65*p.a})`);
          core.addColorStop(0.65, `rgba(255,210,160,${0.28*p.a})`);
          core.addColorStop(1.0, 'rgba(0,0,0,0)');
          ctx.fillStyle = core;
          ctx.beginPath();
          ctx.arc(p.x, p.y, rr, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }

        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        const vig = ctx.createRadialGradient(w*0.5, h*0.55, Math.min(w,h)*0.20, w*0.5, h*0.55, Math.min(w,h)*0.88);
        vig.addColorStop(0.0, 'rgba(0,0,0,0)');
        vig.addColorStop(0.65, 'rgba(0,0,0,0.14)');
        vig.addColorStop(1.0, 'rgba(0,0,0,0.34)');
        ctx.fillStyle = vig;
        ctx.fillRect(0,0,w,h);
        ctx.restore();
      }

      // ---------- Clouds (soft blobs) ----------
      function spawnCloud(arr, dir, nowMs, yMin=0.10, yMax=0.45){
        const y = rand(h*yMin, h*yMax);
        const s = rand(0.65, 1.35);
        const speed = rand(10, 26) * dir;
        const x = (dir > 0) ? -w*0.15 : w*1.15;

        const hue = rand(185, 210);
        const tint = hsvToRgb(hue, 0.20, 1.0);

        arr.push({
          x, y,
          vx: speed,
          s,
          a: rand(0.10, 0.22),
          t0: nowMs,
          wob: rand(0, Math.PI*2),
          tint
        });
      }

      function updateAndDrawClouds(arr, dt, tSec, nowMs, dir){
        // spawn sometimes
        if (Math.random() < dt * 0.12){
          spawnCloud(arr, dir, nowMs);
        }

        for (let i=arr.length-1; i>=0; i--){
          const c = arr[i];
          c.wob += dt * 0.35;
          c.x += c.vx * dt;
          c.y += Math.sin(c.wob) * 0.25;

          const off = (dir > 0) ? (c.x > w*1.25) : (c.x < -w*0.25);
          if (off){
            arr.splice(i,1);
            continue;
          }

          const s = c.s;
          const w0 = 220 * s;
          const h0 = 85 * s;

          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          ctx.globalAlpha = c.a;
          ctx.filter = 'blur(14px)';

          const g = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, w0*0.85);
          g.addColorStop(0.0, `rgba(${c.tint.r|0},${c.tint.g|0},${c.tint.b|0},0.40)`);
          g.addColorStop(0.55, `rgba(255,255,255,0.18)`);
          g.addColorStop(1.0, 'rgba(0,0,0,0)');
          ctx.fillStyle = g;
          ctx.fillRect(c.x-w0, c.y-h0, w0*2, h0*2);

          ctx.filter = 'none';
          ctx.restore();
        }
      }

      // ---------- Comets ----------
      function spawnComet(arr){
        const startSide = Math.random() < 0.5 ? 'left' : 'right';
        const x = (startSide === 'left') ? -w*0.10 : w*1.10;
        const y = rand(h*0.05, h*0.42);
        const dir = (startSide === 'left') ? 1 : -1;

        const vx = rand(320, 520) * dir;
        const vy = rand(40, 120);
        const life = rand(0.55, 0.85);

        arr.push({
          x, y,
          vx, vy,
          life,
          age: 0,
          r: rand(2.8, 4.8),
          hue: rand(185, 210)
        });
      }

      function updateAndDrawComets(arr, dt){
        if (Math.random() < dt * 0.22){
          spawnComet(arr);
        }

        for (let i=arr.length-1; i>=0; i--){
          const c = arr[i];
          c.age += dt;
          c.x += c.vx * dt;
          c.y += c.vy * dt;

          const t = clamp(c.age / c.life, 0, 1);
          const a = (1 - t) * 0.55;

          if (t >= 1){
            arr.splice(i,1);
            continue;
          }

          const col = hsvToRgb(c.hue, 0.25, 1.0);

          // tail
          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          ctx.globalAlpha = a;
          ctx.filter = 'blur(2.5px)';

          const tailLen = 180;
          const tx = c.x - (c.vx>0 ? 1 : -1) * tailLen;
          const ty = c.y - tailLen*0.22;

          const g = ctx.createLinearGradient(c.x, c.y, tx, ty);
          g.addColorStop(0.0, `rgba(255,255,255,0.30)`);
          g.addColorStop(0.35, `rgba(${col.r|0},${col.g|0},${col.b|0},0.22)`);
          g.addColorStop(1.0, 'rgba(0,0,0,0)');

          ctx.strokeStyle = g;
          ctx.lineWidth = 5.0;
          ctx.beginPath();
          ctx.moveTo(c.x, c.y);
          ctx.lineTo(tx, ty);
          ctx.stroke();

          // head glow
          const halo = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, 40);
          halo.addColorStop(0.0, `rgba(255,255,255,0.30)`);
          halo.addColorStop(0.35, `rgba(${col.r|0},${col.g|0},${col.b|0},0.18)`);
          halo.addColorStop(1.0, 'rgba(0,0,0,0)');
          ctx.fillStyle = halo;
          ctx.fillRect(c.x-60, c.y-60, 120, 120);

          ctx.filter = 'none';
          ctx.restore();

          // core dot
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          ctx.globalAlpha = a;
          ctx.fillStyle = 'rgba(255,255,255,0.75)';
          ctx.beginPath();
          ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }
      }

      // ---------- Lunar scene ----------
      function updateAndDrawLunar(dt, tSec, nowMs){
        // big moon gliding (left->right like before)
        lunar.x += lunar.speed * dt;
        if (lunar.x > w + lunar.r*1.25) lunar.x = -lunar.r*1.25;

        lunar.glow = Math.max(0, lunar.glow - dt * 1.1);

        // Comets across the sky
        updateAndDrawComets(lunarComets, dt);

        // Clouds sometimes drift right->left
        updateAndDrawClouds(lunarClouds, dt, tSec, nowMs, -1);

        const rr = lunar.r;
        const glow = 0.18 + 0.75*lunar.glow;

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const halo = ctx.createRadialGradient(lunar.x, lunar.y, rr*0.15, lunar.x, lunar.y, rr*2.9);
        halo.addColorStop(0.0, `rgba(220,245,255,${0.22*glow})`);
        halo.addColorStop(0.55, `rgba(180,220,255,${0.08*glow})`);
        halo.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const body = ctx.createRadialGradient(lunar.x, lunar.y, rr*0.04, lunar.x, lunar.y, rr*1.05);
        body.addColorStop(0.0, 'rgba(245,250,255,0.98)');
        body.addColorStop(0.52, 'rgba(210,235,255,0.42)');
        body.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = body;
        ctx.beginPath();
        ctx.arc(lunar.x, lunar.y, rr, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const hl = ctx.createRadialGradient(lunar.x - rr*0.22, lunar.y - rr*0.22, rr*0.02, lunar.x - rr*0.22, lunar.y - rr*0.22, rr*0.55);
        hl.addColorStop(0.0, `rgba(255,255,255,${0.28 + 0.28*lunar.glow})`);
        hl.addColorStop(0.45, 'rgba(255,255,255,0.10)');
        hl.addColorStop(1.0, 'rgba(255,255,255,0)');
        ctx.fillStyle = hl;
        ctx.filter = 'blur(0.8px)';
        ctx.beginPath();
        ctx.arc(lunar.x - rr*0.10, lunar.y - rr*0.10, rr*0.68, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // ---------- Sun scene (loop) ----------
      function drawSunSkyForPhase(p){
        // p 0..1 for dayness
        const topFrom = { r: 18, g: 8,  b: 20 };
        const midFrom = { r: 64, g: 18, b: 32 };
        const botFrom = { r: 10, g: 16, b: 42 };

        const topTo   = { r: 120, g: 190, b: 255 };
        const midTo   = { r: 80,  g: 160, b: 255 };
        const botTo   = { r: 40,  g: 120, b: 235 };

        const top = lerpColor(topFrom, topTo, p);
        const mid = lerpColor(midFrom, midTo, p);
        const bot = lerpColor(botFrom, botTo, p);

        const g = ctx.createLinearGradient(0,0,0,h);
        g.addColorStop(0.0, toRGBA(top, 1));
        g.addColorStop(0.55, toRGBA(mid, 1));
        g.addColorStop(1.0, toRGBA(bot, 1));

        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = g;
        ctx.fillRect(0,0,w,h);
        ctx.restore();
      }

      function drawSunSphere(x,y,r){
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const halo = ctx.createRadialGradient(x, y, r*0.2, x, y, r*3.3);
        halo.addColorStop(0.0, 'rgba(255,245,210,0.28)');
        halo.addColorStop(0.35, 'rgba(255,205,120,0.16)');
        halo.addColorStop(0.85, 'rgba(255,205,120,0.06)');
        halo.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const body = ctx.createRadialGradient(x, y, r*0.04, x, y, r*1.05);
        body.addColorStop(0.0, 'rgba(255,255,255,0.95)');
        body.addColorStop(0.22, 'rgba(255,245,190,0.90)');
        body.addColorStop(0.62, 'rgba(255,200,90,0.60)');
        body.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = body;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      function drawSunMoon(x,y,r,glow){
        const g = 0.22 + 0.78*glow;

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const halo = ctx.createRadialGradient(x, y, r*0.15, x, y, r*2.7);
        halo.addColorStop(0.0, `rgba(220,245,255,${0.22*g})`);
        halo.addColorStop(0.55, `rgba(180,220,255,${0.08*g})`);
        halo.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const body = ctx.createRadialGradient(x, y, r*0.04, x, y, r*1.08);
        body.addColorStop(0.0, 'rgba(245,250,255,0.98)');
        body.addColorStop(0.52, 'rgba(210,235,255,0.42)');
        body.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = body;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      function updateAndDrawSunScene(dt, tSec, nowMs){
        sunScene.t += dt;
        if (sunScene.t > sunScene.cycle) sunScene.t -= sunScene.cycle;

        const t = sunScene.t;

        // Clouds drift left->right sometimes (across both day & night phases)
        updateAndDrawClouds(sunScene.clouds, dt, tSec, nowMs, +1);

        // Decide phase
        // A: 0..12 sun rising
        // B: 12..20 night, moon right->left traverse (8s)
        // C: 20..32 sun rising again
        let dayness = 0;
        let sunY = h + sunScene.sunR*1.15;

        if (t < 12){
          const p = easeInOutCubic(clamp(t/12,0,1));
          dayness = p;
          sunY = lerp(h + sunScene.sunR*1.15, h*0.42, p);
        } else if (t < 20){
          // night
          dayness = 0.0;
          sunY = h + sunScene.sunR*1.20; // dipped
        } else {
          const p = easeInOutCubic(clamp((t-20)/12,0,1));
          dayness = p;
          sunY = lerp(h + sunScene.sunR*1.15, h*0.42, p);
        }

        drawSunSkyForPhase(dayness);

        // add some stars during night
        if (dayness < 0.25){
          ctx.save();
          ctx.globalAlpha = (0.35 - dayness) * 1.2;
          drawStarLayer(starsFar,  tSec, 0, 0);
          drawStarLayer(starsMid,  tSec, 0, 0);
          drawStarLayer(starsNear, tSec, 0, 0);
          ctx.restore();
        }

        // draw sun when above-ish
        if (dayness > 0.10){
          drawSunSphere(w*0.5, sunY, sunScene.sunR);
        }

        // moon traverse during night window 12..20, right->left over 8s
        if (t >= 12 && t < 20){
          const p = clamp((t-12)/8, 0, 1);
          const e = easeInOutCubic(p);
          sunMoon.x = lerp(w + sunMoon.r*1.2, -sunMoon.r*1.2, e);
          sunMoon.glow = 0.25 + 0.25*Math.sin(tSec*0.6);
          drawSunMoon(sunMoon.x, sunMoon.y, sunMoon.r, sunMoon.glow);
        }
      }

      // ---------- Gravity aesthetics ----------
      function drawGravityBody(b, tSec){
        const hue = b.hue;
        const core = hsvToRgb(hue, 0.18, 1.0);
        const rim  = hsvToRgb(hue+12, 0.35, 1.0);
        const glow = hsvToRgb(hue+6,  0.45, 1.0);

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const halo = ctx.createRadialGradient(b.x, b.y, b.r*0.20, b.x, b.y, b.r*3.2);
        halo.addColorStop(0.0, `rgba(${glow.r|0},${glow.g|0},${glow.b|0},0.18)`);
        halo.addColorStop(0.55, `rgba(${glow.r|0},${glow.g|0},${glow.b|0},0.07)`);
        halo.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const body = ctx.createRadialGradient(b.x, b.y, b.r*0.05, b.x, b.y, b.r*1.10);
        body.addColorStop(0.0, `rgba(255,255,255,0.55)`);
        body.addColorStop(0.22, `rgba(${core.r|0},${core.g|0},${core.b|0},0.45)`);
        body.addColorStop(0.62, `rgba(${rim.r|0},${rim.g|0},${rim.b|0},0.26)`);
        body.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = body;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        // subtle inner swirls for "alive" feeling
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.08;
        ctx.rotate(tSec*0.06 + hue*0.01);
        for (let i=0;i<9;i++){
          const rr = lerp(b.r*0.15, b.r*0.95, i/8);
          ctx.lineWidth = lerp(1.0, 3.6, i/8);
          const col = hsvToRgb(hue + i*6, 0.32, 1.0);
          ctx.strokeStyle = `rgba(${col.r|0},${col.g|0},${col.b|0},0.18)`;
          ctx.beginPath();
          ctx.arc(0,0, rr, 0.2*i, 0.2*i + 1.0 + 0.6*Math.sin(tSec*0.6+i));
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawGravitySat(s){
        const rr = s.rBase;
        const col = hsvToRgb(s.hue, 0.30, 1.0);
        const col2 = hsvToRgb(s.hue+18, 0.45, 1.0);
        const g = 0.22 + 0.78*s.glow;

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const halo = ctx.createRadialGradient(s.x, s.y, rr*0.2, s.x, s.y, rr*6.0);
        halo.addColorStop(0.0, `rgba(${col2.r|0},${col2.g|0},${col2.b|0},${0.18*g})`);
        halo.addColorStop(0.45, `rgba(${col.r|0},${col.g|0},${col.b|0},${0.10*g})`);
        halo.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const body = ctx.createRadialGradient(s.x, s.y, rr*0.03, s.x, s.y, rr*1.15);
        body.addColorStop(0.0, 'rgba(255,255,255,0.72)');
        body.addColorStop(0.35, `rgba(${col.r|0},${col.g|0},${col.b|0},0.36)`);
        body.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = body;
        ctx.beginPath();
        ctx.arc(s.x, s.y, rr, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      function updateAndDrawGravity(dt, tSec, nowMs){
        initGravity(false);

        for (const s of gravity.sats){
          if (s.dragging) continue;
          const b = gravity.bodies[s.bodyIndex];
          s.angle += s.omega * dt;
          s.x = b.x + Math.cos(s.angle) * s.orbitRadius;
          s.y = b.y + Math.sin(s.angle) * s.orbitRadius * 0.78;
          s.glow = Math.max(0, s.glow - dt * 0.9);
        }

        // orbit guides (soft)
        ctx.save();
        ctx.globalAlpha = 0.11;
        ctx.strokeStyle = 'rgba(210,250,255,0.16)';
        ctx.lineWidth = 1;
        for (const s of gravity.sats){
          const b = gravity.bodies[s.bodyIndex];
          ctx.beginPath();
          ctx.ellipse(b.x, b.y, s.orbitRadius, s.orbitRadius*0.78, 0, 0, Math.PI*2);
          ctx.stroke();
        }
        ctx.restore();

        // bodies
        for (const b of gravity.bodies){
          drawGravityBody(b, tSec);
        }

        // satellites
        for (const s of gravity.sats){
          drawGravitySat(s);
        }
      }

     <script>
(() => {
  // ---------- Utilities ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const lerpColor = (c1, c2, t) => ({ r: lerp(c1.r,c2.r,t), g: lerp(c1.g,c2.g,t), b: lerp(c1.b,c2.b,t) });
  const toRGBA = (c, a=1) => `rgba(${c.r|0},${c.g|0},${c.b|0},${a})`;
  const easeInOutCubic = t => (t < 0.5) ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;
  const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
  const rand = (a,b)=> lerp(a,b,Math.random());

  function hsvToRgb(h, s, v){
    h = ((h % 360) + 360) % 360;
    s = clamp(s,0,1); v = clamp(v,0,1);
    const c = v*s;
    const x = c * (1 - Math.abs(((h/60)%2) - 1));
    const m = v - c;
    let r=0,g=0,b=0;
    if (h<60)      { r=c; g=x; b=0; }
    else if (h<120){ r=x; g=c; b=0; }
    else if (h<180){ r=0; g=c; b=x; }
    else if (h<240){ r=0; g=x; b=c; }
    else if (h<300){ r=x; g=0; b=c; }
    else           { r=c; g=0; b=x; }
    return { r: (r+m)*255, g:(g+m)*255, b:(b+m)*255 };
  }

  // ---------- DOM ----------
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d', { alpha:true });

  const bgm = document.getElementById('bgm');
  const welcome = document.getElementById('welcome');
  const startBtn = document.getElementById('startBtn');
  const pressToPlay = document.getElementById('pressToPlay');
  const backBtn = document.getElementById('backBtn');

  const messageCard = document.getElementById('messageCard');
  const messageText = document.getElementById('messageText');

  // ---------- Sizing ----------
  let w=0, h=0, dpr=1;

  // ---------- Background Starfield ----------
  function makeStars(count, depthMin, depthMax){
    const arr=[];
    for(let i=0;i<count;i++){
      arr.push({
        x: Math.random(),
        y: Math.random(),
        r: rand(0.6, 1.8),
        a: rand(0.22, 0.85),
        d: rand(depthMin, depthMax),
        tw: Math.random() * Math.PI * 2,
        twSp: rand(0.10, 0.32)
      });
    }
    return arr;
  }
  const starsNear = makeStars(95, 0.18, 0.35);
  const starsMid  = makeStars(150, 0.35, 0.70);
  const starsFar  = makeStars(210, 0.70, 1.15);

  function drawStarLayer(stars, t, driftX, driftY){
    for(const s of stars){
      const tw = 0.78 + 0.22 * Math.sin(s.tw + t * s.twSp);
      const x = (s.x * w + driftX * (1/s.d)) % w;
      const y = (s.y * h + driftY * (1/s.d)) % h;
      const rr = s.r * tw;

      ctx.beginPath();
      ctx.fillStyle = `rgba(255,255,255,${s.a * tw})`;
      ctx.arc(x < 0 ? x + w : x, y < 0 ? y + h : y, rr, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawBackground(tSec){
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, '#020617');
    g.addColorStop(0.6, '#06102a');
    g.addColorStop(1, '#0b1d4a');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    const driftX = Math.sin(tSec * 0.05) * 40 + Math.cos(tSec * 0.03) * 25;
    const driftY = Math.cos(tSec * 0.04) * 30 + Math.sin(tSec * 0.06) * 18;

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    drawStarLayer(starsFar,  tSec, driftX*0.25, driftY*0.25);
    drawStarLayer(starsMid,  tSec, driftX*0.55, driftY*0.55);
    drawStarLayer(starsNear, tSec, driftX*0.95, driftY*0.95);
    ctx.restore();
  }

  // ---------- Palettes ----------
  const PALETTES = [
    { core:{r:200,g:250,b:255}, plasma:{r:143,g:243,b:255}, corona:{r:168,g:160,b:255}, spark:{r:255,g:255,b:255} },
    { core:{r:255,g:240,b:210}, plasma:{r:255,g:210,b:120}, corona:{r:255,g:170,b:90},  spark:{r:255,g:255,b:255} },
    { core:{r:210,g:255,b:240}, plasma:{r:140,g:255,b:220}, corona:{r:120,g:200,b:255}, spark:{r:255,g:255,b:255} },
    { core:{r:255,g:220,b:235}, plasma:{r:255,g:170,b:210}, corona:{r:200,g:170,b:255}, spark:{r:255,g:255,b:255} },
  ];

  let palette = structuredClone(PALETTES[0]);
  let paletteFrom = structuredClone(palette);
  let paletteTo = structuredClone(palette);
  let paletteTweenT0 = 0;
  let paletteTweenDur = 850;

  function pickNewPalette(nowMs){
    const next = PALETTES[Math.floor(Math.random() * PALETTES.length)];
    paletteFrom = structuredClone(palette);
    paletteTo = structuredClone(next);
    paletteTweenT0 = nowMs;
  }
  function updatePalette(nowMs){
    const t = clamp((nowMs - paletteTweenT0) / paletteTweenDur, 0, 1);
    const tt = easeOutCubic(t);
    palette = {
      core:  lerpColor(paletteFrom.core,  paletteTo.core,  tt),
      plasma:lerpColor(paletteFrom.plasma,paletteTo.plasma,tt),
      corona:lerpColor(paletteFrom.corona,paletteTo.corona,tt),
      spark: lerpColor(paletteFrom.spark, paletteTo.spark, tt)
    };
  }

  // ---------- Message overlay ----------
  let messageTimers = [];
  function clearMessageTimers(){
    for (const id of messageTimers) clearTimeout(id);
    messageTimers = [];
  }
  function setMessageVisible(isVisible){
    if (!messageCard) return;
    if (isVisible) messageCard.classList.add('isVisible');
    else messageCard.classList.remove('isVisible');
  }
  function showMessage(text){
    if (messageText) messageText.textContent = text;
    requestAnimationFrame(() => setMessageVisible(true));
  }
  function hideMessage(){ setMessageVisible(false); }
  function showOneShot(text, totalMs=5200){
    clearMessageTimers();
    const fadeMs = 600;
    const holdMs = Math.max(0, totalMs - (fadeMs*2));
    showMessage(text);
    messageTimers.push(setTimeout(() => hideMessage(), fadeMs + holdMs));
    messageTimers.push(setTimeout(() => hideMessage(), totalMs + 20));
  }

  // ---------- Scenes ----------
  const SCENES = {
    STAR: 'star',
    LANTERN: 'lantern',
    LUNAR: 'lunar',
    SUN: 'sun',
    OCEAN: 'ocean',
    GRAVITY: 'gravity',
  };

  let scene = SCENES.STAR;
  let allowInput = false;

  function updateBackButton(){
    const show = (allowInput && scene !== SCENES.STAR);
    backBtn.style.display = show ? 'block' : 'none';
  }

  // ---------- Celestial objects ----------
  function makeCelestial(){
    return {
      cx:0, cy:0, rBase:0,
      rot:0, rot2:0,
      scale:1,
      intensity: 1,
      state:'idle',
      t0:0,
      bloomUpMs: 8000,
      returnMs: 2400,
    };
  }
  const star = makeCelestial();

  // ---------- Satellites ----------
  const satellites = [];
  const SAT_COUNT = 5;
  const SAT_TO_SCENE = {
    0: SCENES.LANTERN,
    1: SCENES.LUNAR,
    2: SCENES.SUN,
    3: SCENES.OCEAN,
    4: SCENES.GRAVITY,
  };

  // ---------- Lantern / Lunar / Sun / Ocean / Gravity (minimal state) ----------
  const lanterns = [];
  const lunar = { x:0, y:0, r:120, speed:18, glow:0 };
  const sunScene = { sunR:130, clouds:[], t:0, cycle:32 };
  const sunMoon = { x:0, y:0, r:100, glow:0 };
  const ocean = { lights: [], motes: [] };
  const gravity = { bodies: [], sats: [], drag: { active:false, satIndex:-1, pointerId:null } };

  // ---------- Layout / resize ----------
  function computeLayout(){
    const minDim = Math.min(w, h);
    star.cx = w * 0.5;
    star.cy = h * 0.42;
    star.rBase = clamp(minDim * 0.165, 96, 190);

    lunar.r = clamp(minDim * 0.16, 90, 170);
    lunar.y = h * 0.36;

    sunScene.sunR = clamp(minDim * 0.18, 95, 185);
    sunMoon.r = clamp(minDim * 0.12, 72, 140);
    sunMoon.y = h * 0.30;
  }

  function resize(){
    dpr = Math.min(2, window.devicePixelRatio || 1);
    w = Math.floor(window.innerWidth);
    h = Math.floor(window.innerHeight);
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    computeLayout();
    initSatellites(true);
  }
  window.addEventListener('resize', resize, { passive:true });

  function initSatellites(force=false){
    if (satellites.length && !force) return;
    satellites.length = 0;
    for(let i=0;i<SAT_COUNT;i++){
      const baseR = star.rBase * rand(1.20, 1.95);
      const ang = Math.random() * Math.PI * 2;
      satellites.push({
        id: i,
        orbitRadius: baseR,
        angle: ang,
        omega: rand(0.10, 0.24) * (Math.random() < 0.5 ? 1 : -1),
        x: star.cx + Math.cos(ang)*baseR,
        y: star.cy + Math.sin(ang)*baseR,
        rBase: clamp(star.rBase * rand(0.12, 0.18), 16, 34),
        scale: 1,
        state: 'idle',
        t0: 0,
        swellUpMs: 900,
        returnMs: 650,
        tint: Math.random() < 0.5 ? 'cool' : 'warm',
        dragging: false
      });
    }
  }

  // ---------- Simple celestial draw (re-uses your palette look) ----------
  function drawCelestial(obj, tSec){
    const r = obj.rBase * obj.scale;

    ctx.save();
    ctx.globalCompositeOperation = 'screen';

    const spill = ctx.createRadialGradient(obj.cx, obj.cy, r*0.25, obj.cx, obj.cy, r*2.65);
    spill.addColorStop(0.0, toRGBA(palette.corona, 0.16 * obj.intensity));
    spill.addColorStop(0.55, toRGBA(palette.plasma, 0.06 * obj.intensity));
    spill.addColorStop(1.0, 'rgba(0,0,0,0)');
    ctx.fillStyle = spill;
    ctx.fillRect(0,0,w,h);

    const core = ctx.createRadialGradient(obj.cx, obj.cy, r*0.02, obj.cx, obj.cy, r*0.85);
    core.addColorStop(0.0, toRGBA(palette.core, 0.98));
    core.addColorStop(0.35, toRGBA(palette.core, 0.55));
    core.addColorStop(0.75, toRGBA(palette.plasma, 0.20));
    core.addColorStop(1.0, 'rgba(0,0,0,0)');
    ctx.fillStyle = core;
    ctx.beginPath();
    ctx.arc(obj.cx, obj.cy, r*0.85, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawSatellite(s){
    const rr = s.rBase * s.scale;
    const glow = (s.tint === 'cool') ? { r: 143, g: 243, b: 255 } : { r: 255, g: 200, b: 120 };
    const core = (s.tint === 'cool') ? { r: 210, g: 250, b: 255 } : { r: 255, g: 240, b: 210 };

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const halo = ctx.createRadialGradient(s.x, s.y, rr*0.25, s.x, s.y, rr*2.2);
    halo.addColorStop(0.0, toRGBA(glow, 0.14));
    halo.addColorStop(0.55, toRGBA(glow, 0.05));
    halo.addColorStop(1.0, 'rgba(0,0,0,0)');
    ctx.fillStyle = halo;
    ctx.fillRect(0,0,w,h);
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    const body = ctx.createRadialGradient(s.x, s.y, rr*0.03, s.x, s.y, rr*1.0);
    body.addColorStop(0.0, toRGBA(core, 0.92));
    body.addColorStop(0.35, toRGBA(glow, 0.28));
    body.addColorStop(0.80, toRGBA(glow, 0.10));
    body.addColorStop(1.0, 'rgba(0,0,0,0)');
    ctx.fillStyle = body;
    ctx.beginPath();
    ctx.arc(s.x, s.y, rr, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // ---------- Animations ----------
  function updateStarIdle(nowMs){
    const t = nowMs * 0.001;
    star.scale = 1 + 0.020 * Math.sin(t * 2 * Math.PI / 6.2);
    star.intensity = 1.0 + 0.06 * (0.5 + 0.5*Math.sin(t * 2*Math.PI / 7.2));
  }
  function startBloom(nowMs){
    pickNewPalette(nowMs);
    star.state = 'bloomUp';
    star.t0 = nowMs;
  }
  function updateStar(nowMs){
    if (star.state === 'idle'){
      updateStarIdle(nowMs);
      return;
    }
    if (star.state === 'bloomUp'){
      const t = clamp((nowMs - star.t0) / star.bloomUpMs, 0, 1);
      const e = easeInOutCubic(t);
      star.scale = lerp(1.0, 3.0, e);
      star.intensity = 1.05 + 0.90 * easeInOutCubic(t);
      if (t >= 1){ star.state = 'return'; star.t0 = nowMs; }
      return;
    }
    if (star.state === 'return'){
      const t = clamp((nowMs - star.t0) / star.returnMs, 0, 1);
      const e = easeOutCubic(t);
      star.scale = lerp(3.0, 1.0, e);
      star.intensity = 1.15 - 0.30*e;
      if (t >= 1){ star.state = 'idle'; }
    }
  }

  function updateSatellitePositions(dt){
    for (const s of satellites){
      if (s.dragging) continue;
      s.angle += s.omega * dt;
      s.x = star.cx + Math.cos(s.angle) * s.orbitRadius;
      s.y = star.cy + Math.sin(s.angle) * s.orbitRadius;
    }
  }

  function updateSatelliteSwell(s, nowMs){
    if (s.state === 'idle'){
      const t = nowMs * 0.001;
      s.scale = 1 + 0.010 * Math.sin(t * 2*Math.PI / (5.2 + s.id*0.6));
      return;
    }
    if (s.state === 'swellUp'){
      const t = clamp((nowMs - s.t0) / s.swellUpMs, 0, 1);
      s.scale = lerp(1.0, 1.85, easeOutCubic(t));
      if (t >= 1){ s.state = 'return'; s.t0 = nowMs; }
      return;
    }
    if (s.state === 'return'){
      const t = clamp((nowMs - s.t0) / s.returnMs, 0, 1);
      s.scale = lerp(1.85, 1.0, easeOutCubic(t));
      if (t >= 1) s.state = 'idle';
    }
  }

  // ---------- Hit tests ----------
  function inHitCircle(x,y,cx,cy,r){
    const dx = x - cx, dy = y - cy;
    return (dx*dx + dy*dy) <= r*r;
  }
  function hitSatellite(x,y){
    for (let i = satellites.length - 1; i >= 0; i--){
      const s = satellites[i];
      const rr = s.rBase * 1.75;
      if (inHitCircle(x,y,s.x,s.y,rr)) return i;
    }
    return -1;
  }

  // ---------- Double tap ----------
  const dbl = { lastKey:'', lastT:0, maxGap:360 };
  function isDoubleTap(key, now){
    if (dbl.lastKey === key && (now - dbl.lastT) <= dbl.maxGap){
      dbl.lastKey = '';
      dbl.lastT = 0;
      return true;
    }
    dbl.lastKey = key;
    dbl.lastT = now;
    return false;
  }

  // ---------- Drag ----------
  const drag = { active:false, satIndex:-1, pointerId:null };

  // ---------- Scene navigation ----------
  function goToScene(next){
    scene = next;
    updateBackButton();
    hideMessage();
    dbl.lastKey = '';
    dbl.lastT = 0;
  }

  backBtn.addEventListener('click', () => {
    if (!allowInput) return;
    goToScene(SCENES.STAR);
  });

  // ---------- Start button ----------
  startBtn.addEventListener('click', async () => {
    welcome.classList.remove('active');
    pressToPlay.style.display = 'block';
    allowInput = true;
    updateBackButton();
    showOneShot("Tip: Double tap a satellite to enter Boo Planet.", 5200);

    try {
      await bgm.play();
    } catch {
      // Autoplay can fail until a user gesture; the click usually counts, but ignore if blocked.
    }
  });

  // ---------- Input (FIXED) ----------
  canvas.addEventListener('pointerdown', (e) => {
    if (!allowInput) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const now = performance.now();

    // STAR scene interactions
    if (scene === SCENES.STAR){
      // star tap -> bloom
      if (inHitCircle(x,y, star.cx, star.cy, star.rBase * 0.95)){
        startBloom(now);
        return;
      }

      // satellite tap / dbl-tap
      const si = hitSatellite(x,y);
      if (si !== -1){
        const s = satellites[si];
        s.state = 'swellUp';
        s.t0 = now;

        const key = `sat-${si}`;
        if (isDoubleTap(key, now)){
          // enter the scene mapped to that satellite
          goToScene(SAT_TO_SCENE[si] || SCENES.STAR);
          return;
        }

        // start drag
        drag.active = true;
        drag.satIndex = si;
        drag.pointerId = e.pointerId;
        s.dragging = true;
        canvas.setPointerCapture(e.pointerId);
        return;
      }
    }

    // Other scenes: back button exists; feel free to extend per-scene taps later
  }, { passive:false });

  canvas.addEventListener('pointermove', (e) => {
    if (!allowInput) return;
    if (!drag.active) return;
    if (e.pointerId !== drag.pointerId) return;
    if (drag.satIndex < 0) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const s = satellites[drag.satIndex];
    s.x = x;
    s.y = y;

    // recompute orbit from position
    const dx = s.x - star.cx;
    const dy = s.y - star.cy;
    const r = Math.sqrt(dx*dx + dy*dy);
    s.orbitRadius = clamp(r, star.rBase * 0.85, Math.min(w,h) * 0.48);
    s.angle = Math.atan2(dy, dx);
  }, { passive:false });

  function endDrag(e){
    if (!drag.active) return;
    if (e.pointerId !== drag.pointerId) return;
    const s = satellites[drag.satIndex];
    if (s) s.dragging = false;
    drag.active = false;
    drag.satIndex = -1;
    drag.pointerId = null;
  }

  canvas.addEventListener('pointerup', endDrag, { passive:true });
  canvas.addEventListener('pointercancel', endDrag, { passive:true });

  // ---------- Main loop (FIXED: tick exists now) ----------
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    const tSec = now / 1000;

    updatePalette(now);

    // Background always
    drawBackground(tSec);

    // STAR scene draw
    if (scene === SCENES.STAR){
      updateStar(now);
      updateSatellitePositions(dt);

      for (const s of satellites) updateSatelliteSwell(s, now);

      drawCelestial(star, tSec);
      for (const s of satellites) drawSatellite(s);
    } else {
      // Placeholder: other scenes not reimplemented in this patch block
      // (Your original functions exist earlier in your full file)
      // Keep the star background so it doesnât look âblankâ
      ctx.save();
      ctx.globalAlpha = 0.45;
      drawCelestial(star, tSec);
      ctx.restore();
    }

    requestAnimationFrame(tick);
  }

  // ---------- Boot ----------
  resize();
  initSatellites(true);
  requestAnimationFrame(tick);
})();
</script>
