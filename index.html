please update this index.html code so that on the Lantern scene, there is a moon-like celestial body at the centre of the screen around which the lanterns hover... I want the lantern scene to be as aesthetically appealing as possible... <!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Boo Planet (v1.6)</title>

  <!-- Retro arcade font (online). If you want offline, download and self-host. -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg0:#020617;
      --bg1:#06102a;
      --bg2:#0b1d4a;

      --text:#F4F8FF;
      --muted:rgba(214,230,255,0.80);

      --glass: rgba(10, 24, 58, 0.38);
      --glass2: rgba(10, 24, 58, 0.26);
      --radius: 22px;
      --shadow: 0 24px 70px rgba(0,0,0,.55);

      --arcadeBlue1:#2aa8ff;
      --arcadeBlue2:#0a4ee6;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }

    body{
      margin:0;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background: linear-gradient(180deg, var(--bg0), var(--bg1) 55%, var(--bg2));
      overflow:hidden;
    }

    #stage{
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
    }

    .ui{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      pointer-events:none;
    }

    .panel{
      width:min(760px, 100%);
      border-radius: var(--radius);
      background:
        radial-gradient(900px 420px at 20% 12%, rgba(255,255,255,0.08), rgba(0,0,0,0) 55%),
        linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02)),
        var(--glass);
      border:1px solid rgba(255,255,255,0.12);
      box-shadow: var(--shadow);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      overflow:hidden;
      padding:22px;
      pointer-events:auto;
    }

    .screen{ display:none; }
    .screen.active{ display:block; }

    .stack{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:16px;
    }

    .titleArcade{
      font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      letter-spacing: .8px;
      text-shadow: 0 0 18px rgba(255,255,255,0.10), 0 0 36px rgba(143,243,255,0.12);
      margin:0;
      font-size: clamp(18px, 3.2vw, 30px);
      line-height: 1.25;
      text-align:center;
    }

    .copy{
      max-width: 58ch;
      margin: 0 auto;
      text-align:center;
      color: var(--muted);
      line-height: 1.65;
      font-size: 1rem;
    }
    .copy ul{
      list-style: none;
      padding: 0;
      margin: 14px auto 0;
      display: grid;
      gap: 8px;
      width: min(560px, 100%);
    }
    .copy li{
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      border-radius: 14px;
      padding: 10px 12px;
      text-align: left;
    }

    .startBtn{
      font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      letter-spacing: .8px;
      font-size: clamp(14px, 2.2vw, 18px);
      padding: 18px 22px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.14);
      cursor:pointer;
      background:
        radial-gradient(220px 100px at 20% 0%, rgba(255,255,255,0.20), rgba(0,0,0,0) 70%),
        linear-gradient(180deg, rgba(255,255,255,0.10), rgba(0,0,0,0) 42%),
        linear-gradient(180deg, var(--arcadeBlue1), var(--arcadeBlue2));
      color: rgba(244,248,255,0.98);
      text-shadow: 0 0 16px rgba(255,255,255,0.18);
      box-shadow:
        0 20px 50px rgba(0,0,0,0.42),
        0 0 0 1px rgba(255,255,255,0.10) inset,
        0 0 30px rgba(42,168,255,0.20);
      transition: transform .12s ease, filter .12s ease;
      min-width: 180px;
      -webkit-tap-highlight-color: transparent;
    }
    .startBtn:active{ transform: translateY(2px) scale(0.99); filter: brightness(0.98); }

    .hint{
      margin-top: 2px;
      font-size: 0.92rem;
      color: rgba(214,230,255,0.70);
      text-align:center;
    }

    .pressToPlay{
      position:fixed;
      left:0;
      right:0;
      bottom: 14px;
      padding-bottom: env(safe-area-inset-bottom);
      display:none;
      pointer-events:none;
      text-align:center;
      user-select:none;

      font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: clamp(10px, 1.6vw, 13px);
      letter-spacing: .6px;
      color: rgba(244,248,255,0.78);
      text-shadow:
        0 0 18px rgba(255,255,255,0.10),
        0 0 30px rgba(143,243,255,0.10);
      opacity: 0.95;
    }

    .messageWrap{
      position:fixed;
      left: 12px;
      right: 12px;
      top: 12px;
      padding-top: env(safe-area-inset-top);
      display:flex;
      justify-content:center;
      pointer-events:none;
      z-index: 50;
    }
    .messageCard{
      width: min(860px, 100%);
      border-radius: 18px;
      background:
        radial-gradient(900px 420px at 30% 20%, rgba(255,255,255,0.08), rgba(0,0,0,0) 60%),
        linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)),
        var(--glass2);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      box-shadow: 0 18px 46px rgba(0,0,0,.35);
      padding: 12px 14px;
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity 520ms ease, transform 520ms ease;
    }
    .messageCard.isVisible{
      opacity: 1;
      transform: translateY(0);
    }
    .messageText{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: clamp(14px, 1.9vw, 16px);
      line-height: 1.55;
      color: rgba(244,248,255,0.90);
      text-shadow: 0 0 16px rgba(255,255,255,0.08);
      text-align:center;
      margin:0;
      white-space:pre-wrap;
    }

    .backBtn{
      position: fixed;
      left: 12px;
      top: 12px;
      margin-top: env(safe-area-inset-top);
      z-index: 70;
      display: none;
      pointer-events: auto;

      font-family: "Press Start 2P", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12px;
      letter-spacing: .6px;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      color: rgba(244,248,255,0.95);
      background:
        radial-gradient(220px 90px at 20% 0%, rgba(255,255,255,0.16), rgba(0,0,0,0) 70%),
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0) 42%),
        linear-gradient(180deg, rgba(42,168,255,0.78), rgba(10,78,230,0.78));
      box-shadow: 0 18px 40px rgba(0,0,0,0.35);
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      opacity: 0.95;
    }
    .backBtn:active{ transform: translateY(1px) scale(0.99); }

    .copyrightMark{
      position:fixed;
      left:0;
      right:0;
      bottom: 6px;
      padding-bottom: env(safe-area-inset-bottom);
      text-align:center;
      pointer-events:none;
      user-select:none;
      z-index: 60;

      font-size: 0.72rem;
      color: rgba(214,230,255,0.52);
      opacity: 0.92;
      letter-spacing: .2px;
      text-shadow: 0 0 14px rgba(0,0,0,0.45);
    }

    @media (prefers-reduced-motion: reduce){
      .panel, .messageCard{ backdrop-filter:none; -webkit-backdrop-filter:none; }
      .messageCard{ transition:none; }
    }
  </style>
</head>

<body>
  <canvas id="stage" aria-label="Boo Planet stage"></canvas>

  <audio id="bgm" preload="auto" loop>
    <source src="assets/music/boo-planet.mp3" type="audio/mpeg">
  </audio>

  <div class="messageWrap" aria-hidden="true">
    <div class="messageCard" id="messageCard">
      <p class="messageText" id="messageText"></p>
    </div>
  </div>

  <button class="backBtn" id="backBtn" type="button" aria-label="Back">BACK</button>

  <div class="ui">
    <div class="panel screen active" id="welcome">
      <div class="stack">
        <h1 class="titleArcade">Boo Planet</h1>

        <div class="copy">
          <p><strong style="color:rgba(244,248,255,0.95);">This is a sensory cause-and-effect playground.</strong></p>
          <p>A first interaction with screens and a way for your little ones to develop without overstimulation or “wrong” inputs.</p>
          <p></p>
          <ul>
            <li><strong>Cause &amp; effect understanding</strong></li>
            <li><strong>Finer motor control</strong></li>
          </ul>
        </div>

        <button class="startBtn" id="startBtn" type="button" aria-label="Start Boo Planet">START</button>
        <div class="hint"></div>
      </div>
    </div>

    <div class="screen" id="play"></div>
  </div>

  <div class="pressToPlay" id="pressToPlay">Push and pull the satellites or press the celestial body</div>
  <div class="copyrightMark">© 2026 Boo Industries. All rights reserved.</div>

  <script>
    (() => {
      // ---------- Utilities ----------
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const lerpColor = (c1, c2, t) => ({ r: lerp(c1.r,c2.r,t), g: lerp(c1.g,c2.g,t), b: lerp(c1.b,c2.b,t) });
      const toRGBA = (c, a=1) => `rgba(${c.r|0},${c.g|0},${c.b|0},${a})`;
      const easeInOutCubic = t => (t < 0.5) ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;
      const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
      const rand = (a,b)=> lerp(a,b,Math.random());

      // ---------- DOM ----------
      const canvas = document.getElementById('stage');
      const ctx = canvas.getContext('2d', { alpha:true });

      const bgm = document.getElementById('bgm');
      const welcome = document.getElementById('welcome');
      const play = document.getElementById('play');
      const startBtn = document.getElementById('startBtn');
      const pressToPlay = document.getElementById('pressToPlay');

      const messageCard = document.getElementById('messageCard');
      const messageText = document.getElementById('messageText');
      const backBtn = document.getElementById('backBtn');

      // ---------- Sizing ----------
      let w=0, h=0, dpr=1;

      // ---------- Background Starfield ----------
      function makeStars(count, depthMin, depthMax){
        const arr=[];
        for(let i=0;i<count;i++){
          arr.push({
            x: Math.random(),
            y: Math.random(),
            r: rand(0.6, 1.8),
            a: rand(0.22, 0.85),
            d: rand(depthMin, depthMax),
            tw: Math.random() * Math.PI * 2,
            twSp: rand(0.10, 0.32)
          });
        }
        return arr;
      }
      const starsNear = makeStars(95, 0.18, 0.35);
      const starsMid  = makeStars(150, 0.35, 0.70);
      const starsFar  = makeStars(210, 0.70, 1.15);

      function drawStarLayer(stars, t, driftX, driftY){
        for(const s of stars){
          const tw = 0.78 + 0.22 * Math.sin(s.tw + t * s.twSp);
          const x = (s.x * w + driftX * (1/s.d)) % w;
          const y = (s.y * h + driftY * (1/s.d)) % h;
          const rr = s.r * tw;

          ctx.beginPath();
          ctx.fillStyle = `rgba(255,255,255,${s.a * tw})`;
          ctx.arc(x < 0 ? x + w : x, y < 0 ? y + h : y, rr, 0, Math.PI*2);
          ctx.fill();
        }
      }

      function drawBackground(tSec){
        const g = ctx.createLinearGradient(0,0,0,h);
        g.addColorStop(0, '#020617');
        g.addColorStop(0.6, '#06102a');
        g.addColorStop(1, '#0b1d4a');
        ctx.fillStyle = g;
        ctx.fillRect(0,0,w,h);

        const driftX = Math.sin(tSec * 0.05) * 40 + Math.cos(tSec * 0.03) * 25;
        const driftY = Math.cos(tSec * 0.04) * 30 + Math.sin(tSec * 0.06) * 18;

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        drawStarLayer(starsFar,  tSec, driftX*0.25, driftY*0.25);
        drawStarLayer(starsMid,  tSec, driftX*0.55, driftY*0.55);
        drawStarLayer(starsNear, tSec, driftX*0.95, driftY*0.95);
        ctx.restore();

        // soft nebula haze
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const haze1 = ctx.createRadialGradient(w*0.25, h*0.25, 0, w*0.25, h*0.25, Math.min(w,h)*0.65);
        haze1.addColorStop(0.0, 'rgba(168,160,255,0.08)');
        haze1.addColorStop(0.7, 'rgba(143,243,255,0.05)');
        haze1.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = haze1;
        ctx.fillRect(0,0,w,h);

        const haze2 = ctx.createRadialGradient(w*0.78, h*0.35, 0, w*0.78, h*0.35, Math.min(w,h)*0.62);
        haze2.addColorStop(0.0, 'rgba(143,243,255,0.06)');
        haze2.addColorStop(0.7, 'rgba(168,160,255,0.05)');
        haze2.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = haze2;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        // extra cozy sky wash only in lantern scene
        if (scene === 'lantern'){
          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          const sky = ctx.createRadialGradient(w*0.5, h*0.30, 0, w*0.5, h*0.38, Math.min(w,h)*0.85);
          sky.addColorStop(0.0, 'rgba(255,190,120,0.06)');
          sky.addColorStop(0.55, 'rgba(255,160,90,0.03)');
          sky.addColorStop(1.0, 'rgba(0,0,0,0)');
          ctx.fillStyle = sky;
          ctx.fillRect(0,0,w,h);
          ctx.restore();
        }
      }

      // ---------- Palettes ----------
      const PALETTES = [
        { core:{r:200,g:250,b:255}, plasma:{r:143,g:243,b:255}, corona:{r:168,g:160,b:255}, spark:{r:255,g:255,b:255} },
        { core:{r:255,g:240,b:210}, plasma:{r:255,g:210,b:120}, corona:{r:255,g:170,b:90},  spark:{r:255,g:255,b:255} },
        { core:{r:210,g:255,b:240}, plasma:{r:140,g:255,b:220}, corona:{r:120,g:200,b:255}, spark:{r:255,g:255,b:255} },
        { core:{r:255,g:220,b:235}, plasma:{r:255,g:170,b:210}, corona:{r:200,g:170,b:255}, spark:{r:255,g:255,b:255} },
        { core:{r:200,g:230,b:255}, plasma:{r:80,g:220,b:255},  corona:{r:120,g:150,b:255}, spark:{r:255,g:255,b:255} },
      ];

      let palette = structuredClone(PALETTES[0]);
      let paletteFrom = structuredClone(palette);
      let paletteTo = structuredClone(palette);
      let paletteTweenT0 = 0;
      let paletteTweenDur = 850;

      function pickNewPalette(nowMs){
        const next = PALETTES[Math.floor(Math.random() * PALETTES.length)];
        paletteFrom = structuredClone(palette);
        paletteTo = structuredClone(next);
        paletteTweenT0 = nowMs;
      }
      function updatePalette(nowMs){
        const t = clamp((nowMs - paletteTweenT0) / paletteTweenDur, 0, 1);
        const tt = easeOutCubic(t);
        palette = {
          core:  lerpColor(paletteFrom.core,  paletteTo.core,  tt),
          plasma:lerpColor(paletteFrom.plasma,paletteTo.plasma,tt),
          corona:lerpColor(paletteFrom.corona,paletteTo.corona,tt),
          spark: lerpColor(paletteFrom.spark, paletteTo.spark, tt)
        };
      }

      // ---------- Message overlay ----------
      let messagePlaying = false;
      let messageTimers = [];
      function clearMessageTimers(){
        for (const id of messageTimers) clearTimeout(id);
        messageTimers = [];
      }
      function setMessageVisible(isVisible){
        if (isVisible) messageCard.classList.add('isVisible');
        else messageCard.classList.remove('isVisible');
      }
      function showMessage(text){
        messageText.textContent = text;
        requestAnimationFrame(() => setMessageVisible(true));
      }
      function hideMessage(){ setMessageVisible(false); }
      function showOneShot(text, totalMs=5200){
        messagePlaying = true;
        clearMessageTimers();
        const fadeMs = 600;
        const holdMs = Math.max(0, totalMs - (fadeMs*2));
        showMessage(text);
        messageTimers.push(setTimeout(() => hideMessage(), fadeMs + holdMs));
        messageTimers.push(setTimeout(() => {
          hideMessage();
          messagePlaying = false;
        }, totalMs + 20));
      }

      // ---------- Content ----------
      const MOON_FACTS = [
        "Moon fact: Our Moon helps steady Earth’s tilt — that makes seasons more gentle and predictable.",
        "Moon fact: The Moon is moving away from Earth a tiny bit each year (about the width of a fingernail).",
        "Moon fact: Many moons are icy worlds — some may even hide oceans under their surfaces.",
        "Moon fact: Moons can shape their planets — their gravity can cause tides, waves, and even volcanoes."
      ];
      let moonFactIndex = 0;

      const HOLIDAY_MESSAGES = [
        "Festival of Lights: Many cultures celebrate light in the dark season — candles, lanterns, and warmth together.",
        "New Year’s Eve: A gentle goodbye to the old year, and a brave hello to the new.",
        "Lunar New Year: Families gather, share food, and welcome luck with bright colors and joyful sounds.",
        "Diwali: Lamps and lanterns shine to celebrate hope, goodness, and new beginnings.",
        "Hanukkah: A nightly candle reminds us that small light can last longer than we imagine.",
        "Christmas: Cozy traditions — twinkly lights, stories, kindness, and togetherness.",
        "Kwanzaa: A celebration of community, culture, and shared values through seven guiding principles.",
        "Eid: A day of gratitude, generosity, and sweet joy after a season of reflection.",
        "Holi: A celebration of color — playful, bright, and full of laughter.",
        "Mid-Autumn Festival: Mooncakes, lanterns, and looking up together at the same glowing moon.",
        "Winter Solstice: The longest night — and the turning point back toward longer days.",
        "Day of the Dead: Remembering loved ones with stories, flowers, music, and love that stays close.",
        "Vaisakhi: Songs, community meals, and bright spirit to welcome spring and new harvests.",
        "Nowruz: A fresh start at springtime — cleaning, sharing, and planting hope for the year ahead.",
        "Carnival: A joyful parade of costumes, music, and playful celebration before a quieter season.",
        "Light a Lantern: Wherever you are, a little light can be a message: “You are safe. You are loved.”"
      ];

      // ---------- Scenes ----------
      // 'star' -> 'planet' -> 'lantern'
      let scene = 'star';
      let allowInput = false;

      function updateBackButton(){
        const show = (allowInput && (scene === 'planet' || scene === 'lantern'));
        backBtn.style.display = show ? 'block' : 'none';
      }

      // ---------- Celestial objects ----------
      function makeCelestial(){
        return {
          cx:0, cy:0, rBase:0,
          rot:0, rot2:0,
          scale:1,
          intensity: 1,
          state:'idle',
          t0:0,
          bloomUpMs: 8000,
          returnMs: 2400,

          // slower, ceremonial warp
          warpUpMs: 2000,
          warpHoldMs: 650,
          warpDownMs: 450
        };
      }

      const star = makeCelestial();
      const booPlanet = makeCelestial();

      // ---------- Satellites (star scene) ----------
      const satellites = [];
      const SAT_COUNT = 5;

      // ---------- Moon (planet scene) ----------
      const moon = {
        orbitR: 0,
        angle: 0,
        omega: (Math.PI * 2) / 24,
        x: 0, y: 0,
        rBase: 18,
        glow: 0
      };

      // ---------- Lanterns (lantern scene) ----------
      const LANTERN_COUNT = 16;
      const lanterns = [];
      let holidayOrder = [];
      let holidayPtr = 0;

      const VIVID_COLORS = [
        { name:"Vivid Orange",  ember:{r:255,g:120,b:30},  honey:{r:255,g:180,b:90},  cream:{r:255,g:245,b:230}, rim:{r:255,g:95,b:20} },
        { name:"Sky Blue",      ember:{r:80, g:200,b:255}, honey:{r:150,g:235,b:255}, cream:{r:235,g:252,b:255}, rim:{r:40, g:140,b:255} },
        { name:"Lavender",     ember:{r:190,g:140,b:255}, honey:{r:220,g:190,b:255}, cream:{r:250,g:245,b:255}, rim:{r:155,g:95,b:255} },
        { name:"Mint",         ember:{r:80, g:255,b:210}, honey:{r:170,g:255,b:235}, cream:{r:240,g:255,b:250}, rim:{r:30, g:220,b:170} },
        { name:"Rose",         ember:{r:255,g:120,b:190}, honey:{r:255,g:190,b:225}, cream:{r:255,g:245,b:250}, rim:{r:255,g:80, b:155} },
        { name:"Golden",       ember:{r:255,g:205,b:90},  honey:{r:255,g:235,b:175}, cream:{r:255,g:250,b:235}, rim:{r:255,g:180,b:60} },
      ];

      const COZY_BASE = {
        ember:{ r:255, g:168, b: 78 },
        honey:{ r:255, g:205, b:135 },
        cream:{ r:255, g:244, b:220 },
        rim:  { r:255, g:132, b: 44 }
      };

      function shuffle(arr){
        for (let i=arr.length-1;i>0;i--){
          const j = (Math.random() * (i+1)) | 0;
          [arr[i],arr[j]] = [arr[j],arr[i]];
        }
        return arr;
      }

      function computeLayout(){
        const minDim = Math.min(w, h);

        star.cx = w * 0.5;
        star.cy = h * 0.42;
        star.rBase = clamp(minDim * 0.165, 96, 190);

        booPlanet.cx = w * 0.5;
        booPlanet.cy = h * 0.46;
        booPlanet.rBase = clamp(minDim * 0.175, 100, 210);
      }

      function resize(){
        dpr = Math.min(2, window.devicePixelRatio || 1);
        w = Math.floor(window.innerWidth);
        h = Math.floor(window.innerHeight);
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        computeLayout();
        initSatellites(true);
        initLanterns(true);
      }
      window.addEventListener('resize', resize, { passive:true });

      function initSatellites(force=false){
        if (satellites.length && !force) return;
        satellites.length = 0;
        for(let i=0;i<SAT_COUNT;i++){
          const baseR = star.rBase * rand(1.20, 1.95);
          const ang = Math.random() * Math.PI * 2;
          satellites.push({
            id: i,
            orbitRadius: baseR,
            angle: ang,
            omega: rand(0.10, 0.24) * (Math.random() < 0.5 ? 1 : -1),
            x: star.cx + Math.cos(ang)*baseR,
            y: star.cy + Math.sin(ang)*baseR,
            rBase: clamp(star.rBase * rand(0.12, 0.18), 16, 34),
            scale: 1,
            state: 'idle',
            t0: 0,
            swellUpMs: 900,
            returnMs: 650,
            tint: Math.random() < 0.5 ? 'cool' : 'warm',
            dragging: false
          });
        }
      }

      function initLanterns(force=false){
        if (lanterns.length && !force) return;
        lanterns.length = 0;

        // spread lanterns like a sky cluster (upper-mid)
        const topBand = h * 0.18;
        const bottomBand = h * 0.70;
        const leftBand = w * 0.12;
        const rightBand = w * 0.88;

        // nice-ish distribution: ring-ish but not orbiting; then jitter
        const cx = w * 0.5;
        const cy = h * 0.44;
        const ringRx = clamp(Math.min(w,h) * 0.42, 180, 420);
        const ringRy = ringRx * 0.72;

        for (let i=0;i<LANTERN_COUNT;i++){
          const a = (i/LANTERN_COUNT) * Math.PI*2 + rand(-0.22, 0.22);
          let ax = cx + Math.cos(a) * ringRx + rand(-30, 30);
          let ay = cy + Math.sin(a) * ringRy + rand(-28, 28);

          ax = clamp(ax, leftBand, rightBand);
          ay = clamp(ay, topBand, bottomBand);

          lanterns.push({
            id: i,

            // anchor point (where it “belongs” in the sky)
            ax, ay,

            // current position + velocity
            x: ax + rand(-10,10),
            y: ay + rand(-10,10),
            vx: rand(-10,10),
            vy: rand(-8,8),

            // visuals
            r: rand(18, 26),
            rot: rand(0, Math.PI*2),
            rotSp: 0,

            // gentle floating
            wob: rand(0, Math.PI*2),
            wobSp: rand(0.45, 0.95),
            drift: rand(3, 7),      // float radius around anchor
            bob: rand(2, 7),        // vertical bob

            // candle flicker phase
            flick: rand(0, Math.PI*2),

            // color state
            mode: 'cozy',            // 'cozy' or 'vivid'
            vividIndex: (Math.random() * VIVID_COLORS.length) | 0,

            glow: 0
          });
        }

        holidayOrder = shuffle([...Array(HOLIDAY_MESSAGES.length)].map((_,i)=>i));
        holidayPtr = 0;
      }

      // ---------- Drawing helpers (celestial) ----------
      function beginShimmerClip(r, tSec){
        const steps = 84;
        ctx.beginPath();
        for (let i=0;i<=steps;i++){
          const a = (i/steps) * Math.PI*2;
          const n1 = 0.013 * Math.sin(a*3 + tSec*0.9);
          const n2 = 0.010 * Math.sin(a*7 - tSec*0.7);
          const n3 = 0.006 * Math.sin(a*11 + tSec*0.45);
          const rr = r * (1 + n1 + n2 + n3);
          const x = Math.cos(a) * rr;
          const y = Math.sin(a) * rr;
          if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.closePath();
        ctx.clip();
      }

      function drawFlaresFor(obj, r, tSec, intensity){
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.translate(obj.cx, obj.cy);

        const beamCount = 5;
        for (let i=0;i<beamCount;i++){
          const a = tSec*0.08 + i*(Math.PI*2/beamCount);
          const wob = 0.20 * Math.sin(tSec*0.35 + i*2.1);
          const ang = a + wob;

          ctx.save();
          ctx.rotate(ang);
          ctx.globalAlpha = 0.10 * intensity;

          const grad = ctx.createLinearGradient(0, 0, r*2.1, 0);
          grad.addColorStop(0.0, toRGBA(palette.corona, 0.00));
          grad.addColorStop(0.15, toRGBA(palette.corona, 0.18));
          grad.addColorStop(0.45, toRGBA(palette.plasma, 0.10));
          grad.addColorStop(1.0, 'rgba(0,0,0,0)');

          ctx.fillStyle = grad;
          ctx.filter = 'blur(1.2px)';
          ctx.beginPath();
          ctx.moveTo(r*0.35, -r*0.10);
          ctx.lineTo(r*2.05, -r*0.35);
          ctx.lineTo(r*2.05,  r*0.35);
          ctx.lineTo(r*0.35,  r*0.10);
          ctx.closePath();
          ctx.fill();

          ctx.restore();
        }
        ctx.restore();
      }

      function drawCelestial(obj, tSec){
        const r = obj.rBase * obj.scale;
        const intensity = obj.intensity;

        // spill
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const spill = ctx.createRadialGradient(obj.cx, obj.cy, r*0.25, obj.cx, obj.cy, r*2.65);
        spill.addColorStop(0.0, toRGBA(palette.corona, 0.16 * intensity));
        spill.addColorStop(0.55, toRGBA(palette.plasma, 0.06 * intensity));
        spill.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = spill;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        drawFlaresFor(obj, r, tSec, intensity);

        // corona
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const corona = ctx.createRadialGradient(obj.cx, obj.cy, r*0.62, obj.cx, obj.cy, r*1.16);
        corona.addColorStop(0.0, toRGBA(palette.corona, 0.22 * intensity));
        corona.addColorStop(0.55, toRGBA(palette.corona, 0.12 * intensity));
        corona.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = corona;
        ctx.beginPath();
        ctx.arc(obj.cx, obj.cy, r*1.16, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        // body
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.translate(obj.cx, obj.cy);
        beginShimmerClip(r*0.80, tSec);

        const body = ctx.createRadialGradient(0,0, r*0.05, 0,0, r*0.80);
        body.addColorStop(0.0, toRGBA(palette.core, 0.96));
        body.addColorStop(0.32, toRGBA(palette.core, 0.62 * intensity));
        body.addColorStop(0.58, toRGBA(palette.plasma, 0.28 * intensity));
        body.addColorStop(0.86, toRGBA(palette.corona, 0.14 * intensity));
        body.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = body;
        ctx.fillRect(-r, -r, r*2, r*2);

        // swirls
        ctx.save();
        ctx.rotate(obj.rot);
        for (let i=0;i<20;i++){
          const a0 = (i/20) * Math.PI*2;
          const a1 = a0 + lerp(0.10, 0.34, (Math.sin(tSec*0.8 + i)+1)/2);
          const rr = lerp(r*0.16, r*0.78, (i%6)/5);
          ctx.lineWidth = lerp(2.0, 7.0, (i%5)/4);
          ctx.strokeStyle = toRGBA(palette.plasma, (0.10 + 0.08*Math.sin(tSec*0.9+i)) * intensity);
          ctx.beginPath();
          ctx.arc(0,0, rr, a0, a1);
          ctx.stroke();
        }
        ctx.restore();

        ctx.save();
        ctx.rotate(-obj.rot*1.65 + obj.rot2);
        for (let i=0;i<13;i++){
          const a0 = (i/13) * Math.PI*2;
          const a1 = a0 + lerp(0.14, 0.44, (Math.cos(tSec*0.65 + i*1.7)+1)/2);
          const rr = lerp(r*0.20, r*0.76, ((i*7)%13)/12);
          ctx.lineWidth = lerp(1.6, 5.6, (i%4)/3);
          ctx.strokeStyle = toRGBA(palette.corona, (0.08 + 0.07*Math.cos(tSec*0.8+i)) * intensity);
          ctx.beginPath();
          ctx.arc(0,0, rr, a0, a1);
          ctx.stroke();
        }
        ctx.restore();

        // spark flecks
        for (let i=0;i<22;i++){
          const ang = tSec*0.35 + i*0.62;
          const pr = r * lerp(0.08, 0.70, (Math.sin(i*12.3)+1)/2);
          const px = Math.cos(ang) * pr * 0.55;
          const py = Math.sin(ang*1.12) * pr * 0.55;

          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          ctx.fillStyle = toRGBA(palette.spark, 1);
          ctx.shadowColor = toRGBA(palette.spark, 1);
          ctx.shadowBlur = 12;
          ctx.globalAlpha = 0.12 * intensity;
          ctx.beginPath();
          ctx.arc(px, py, lerp(0.8, 2.0, (Math.cos(tSec+i)+1)/2), 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }

        ctx.restore();

        // core
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const core = ctx.createRadialGradient(obj.cx, obj.cy, r*0.02, obj.cx, obj.cy, r*0.44);
        core.addColorStop(0.0, toRGBA(palette.core, 0.98));
        core.addColorStop(0.18, toRGBA(palette.core, 0.70 * intensity));
        core.addColorStop(0.55, toRGBA(palette.plasma, 0.18 * intensity));
        core.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = core;
        ctx.beginPath();
        ctx.arc(obj.cx, obj.cy, r*0.44, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        // highlight
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const hl = ctx.createRadialGradient(obj.cx - r*0.22, obj.cy - r*0.22, r*0.03, obj.cx - r*0.22, obj.cy - r*0.22, r*0.38);
        hl.addColorStop(0.0, `rgba(255,255,255,${0.26 * intensity})`);
        hl.addColorStop(0.45, `rgba(255,255,255,${0.06 * intensity})`);
        hl.addColorStop(1.0, `rgba(255,255,255,0)`);
        ctx.fillStyle = hl;
        ctx.filter = 'blur(0.8px)';
        ctx.beginPath();
        ctx.arc(obj.cx - r*0.12, obj.cy - r*0.12, r*0.50, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // ---------- Satellites ----------
      function drawSatellite(s){
        const rr = s.rBase * s.scale;
        const coolCore = { r: 210, g: 250, b: 255 };
        const coolGlow = { r: 143, g: 243, b: 255 };
        const warmCore = { r: 255, g: 240, b: 210 };
        const warmGlow = { r: 255, g: 200, b: 120 };

        const coreC = (s.tint === 'cool') ? coolCore : warmCore;
        const glowC = (s.tint === 'cool') ? coolGlow : warmGlow;

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const halo = ctx.createRadialGradient(s.x, s.y, rr*0.25, s.x, s.y, rr*2.2);
        halo.addColorStop(0.0, toRGBA(glowC, 0.14));
        halo.addColorStop(0.55, toRGBA(glowC, 0.05));
        halo.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const body = ctx.createRadialGradient(s.x, s.y, rr*0.03, s.x, s.y, rr*1.0);
        body.addColorStop(0.0, toRGBA(coreC, 0.92));
        body.addColorStop(0.35, toRGBA(glowC, 0.28));
        body.addColorStop(0.80, toRGBA(glowC, 0.10));
        body.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = body;
        ctx.beginPath();
        ctx.arc(s.x, s.y, rr, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const hl = ctx.createRadialGradient(s.x - rr*0.25, s.y - rr*0.25, rr*0.02, s.x - rr*0.25, s.y - rr*0.25, rr*0.48);
        hl.addColorStop(0.0, 'rgba(255,255,255,0.35)');
        hl.addColorStop(0.5, 'rgba(255,255,255,0.08)');
        hl.addColorStop(1.0, 'rgba(255,255,255,0)');
        ctx.fillStyle = hl;
        ctx.filter = 'blur(0.6px)';
        ctx.beginPath();
        ctx.arc(s.x - rr*0.10, s.y - rr*0.10, rr*0.60, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // ---------- Moon ----------
      function updateMoon(dt){
        const base = booPlanet.rBase * (scene === 'planet' ? booPlanet.scale : 1);
        moon.orbitR = clamp(base * 1.55, 120, Math.min(w,h) * 0.42);
        moon.rBase = clamp(base * (0.16 * 2.6), 30, 80);

        moon.angle += moon.omega * dt;
        moon.x = booPlanet.cx + Math.cos(moon.angle) * moon.orbitR;
        moon.y = booPlanet.cy + Math.sin(moon.angle) * moon.orbitR * 0.72;

        moon.glow = Math.max(0, moon.glow - dt * 1.4);
      }

      function drawMoon(tSec){
        ctx.save();
        ctx.globalAlpha = 0.22;
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(booPlanet.cx, booPlanet.cy, moon.orbitR, moon.orbitR*0.72, 0, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();

        const rr = moon.rBase;
        const glow = 0.25 + 0.70*moon.glow;

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const halo = ctx.createRadialGradient(moon.x, moon.y, rr*0.2, moon.x, moon.y, rr*3.0);
        halo.addColorStop(0.0, `rgba(200,240,255,${0.18*glow})`);
        halo.addColorStop(0.55, `rgba(180,220,255,${0.07*glow})`);
        halo.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const body = ctx.createRadialGradient(moon.x, moon.y, rr*0.05, moon.x, moon.y, rr*1.12);
        body.addColorStop(0.0, 'rgba(245,250,255,0.96)');
        body.addColorStop(0.45, 'rgba(200,230,255,0.36)');
        body.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = body;
        ctx.beginPath();
        ctx.arc(moon.x, moon.y, rr, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.14;
        for (let i=0;i<10;i++){
          const a = tSec*0.22 + i*0.78;
          const pr = rr * rand(0.12, 0.78);
          const px = moon.x + Math.cos(a) * pr * 0.55;
          const py = moon.y + Math.sin(a*1.12) * pr * 0.45;
          ctx.fillStyle = 'rgba(255,255,255,0.55)';
          ctx.beginPath();
          ctx.arc(px, py, rand(0.8, 2.0), 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
      }

      // ---------- Lantern motion (floating in sky; no orbit target) ----------
      function updateLanterns(dt, tSec){
        // soft bounds (keep them in view)
        const padX = 26;
        const padTop = 18;
        const padBottom = 26;

        const minX = padX;
        const maxX = w - padX;
        const minY = h*0.10 + padTop;
        const maxY = h*0.82 - padBottom;

        // each lantern floats around its anchor + very gentle “wind”
        for (const p of lanterns){
          p.wob += p.wobSp * dt;
          p.flick += (1.6 + p.wobSp) * dt;

          // desired offset around anchor
          const ox = Math.sin(p.wob + p.id*0.7) * p.drift + Math.cos(p.wob*0.63) * (p.drift*0.55);
          const oy = Math.cos(p.wob*1.12 + p.id*0.4) * p.bob;

          // very gentle “wind” (global)
          const windX = Math.sin(tSec*0.18) * 6 + Math.cos(tSec*0.11) * 4;
          const windY = Math.cos(tSec*0.16) * 3;

          const tx = p.ax + ox + windX;
          const ty = p.ay + oy + windY;

          // soft spring toward target (smooth float, no bumbling)
          const dx = tx - p.x;
          const dy = ty - p.y;
          const spring = 0.80; // higher = smoother tracking with less driftiness
          p.vx += dx * spring * dt;
          p.vy += dy * spring * dt;

          // integrate
          p.x += p.vx * dt;
          p.y += p.vy * dt;

          // damping
          const damp = Math.pow(0.982, dt*60);
          p.vx *= damp;
          p.vy *= damp;

          // rotation (gentle)
         p.rot = 0;

          // keep within bounds by nudging anchors (so the whole float pattern stays natural)
          if (p.x < minX){ p.x = minX; p.vx *= -0.25; p.ax += 10; }
          if (p.x > maxX){ p.x = maxX; p.vx *= -0.25; p.ax -= 10; }
          if (p.y < minY){ p.y = minY; p.vy *= -0.25; p.ay += 10; }
          if (p.y > maxY){ p.y = maxY; p.vy *= -0.25; p.ay -= 10; }

          p.ax = clamp(p.ax, minX+20, maxX-20);
          p.ay = clamp(p.ay, minY+20, maxY-20);

          // glow decay
          p.glow = Math.max(0, p.glow - dt * 0.85);
        }

        // soft collisions (occasional bumps, not constant)
        for (let i=0;i<lanterns.length;i++){
          for (let j=i+1;j<lanterns.length;j++){
            const a = lanterns[i], b = lanterns[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const rr = a.r + b.r + 6;
            const d2 = dx*dx + dy*dy;
            if (d2 > 0 && d2 < rr*rr){
              const d = Math.sqrt(d2);
              const nx = dx / d;
              const ny = dy / d;

              const overlap = (rr - d);
              a.x -= nx * overlap * 0.5;
              a.y -= ny * overlap * 0.5;
              b.x += nx * overlap * 0.5;
              b.y += ny * overlap * 0.5;

              // tiny impulse
              const relVx = b.vx - a.vx;
              const relVy = b.vy - a.vy;
              const relN = relVx*nx + relVy*ny;
              if (relN < 0){
                const impulse = (-relN) * 0.60;
                a.vx -= impulse * nx;
                a.vy -= impulse * ny;
                b.vx += impulse * nx;
                b.vy += impulse * ny;
              }

              a.glow = Math.max(a.glow, 1);
              b.glow = Math.max(b.glow, 1);
            }
          }
        }
      }

      function drawLantern(p, tSec){
        const rr = p.r;

        const pal = (p.mode === 'vivid')
          ? VIVID_COLORS[p.vividIndex % VIVID_COLORS.length]
          : COZY_BASE;

        const flicker = 0.82 + 0.18*Math.sin(p.flick);
        const glowUp = 0.18 + 0.82*p.glow;
        const glow = clamp(flicker * (0.55 + glowUp), 0.25, 1.35);

        // outer glow
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const halo = ctx.createRadialGradient(p.x, p.y, rr*0.2, p.x, p.y, rr*4.6);
        halo.addColorStop(0.0, `rgba(${pal.honey.r},${pal.honey.g},${pal.honey.b},${0.18*glow})`);
        halo.addColorStop(0.45, `rgba(${pal.ember.r},${pal.ember.g},${pal.ember.b},${0.10*glow})`);
        halo.addColorStop(0.80, `rgba(${pal.rim.r},${pal.rim.g},${pal.rim.b},${0.05*glow})`);
        halo.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = halo;
        ctx.fillRect(0,0,w,h);
        ctx.restore();

        // lantern body
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);

        // shadow rim
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.20;
        ctx.filter = 'blur(0.6px)';
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        ctx.beginPath();
        ctx.ellipse(0, rr*1.08, rr*0.55, rr*0.20, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        // paper glow gradient
        ctx.globalCompositeOperation = 'lighter';
        const grad = ctx.createRadialGradient(0, -rr*0.15, rr*0.10, 0, 0, rr*1.60);
        grad.addColorStop(0.0, `rgba(${pal.cream.r},${pal.cream.g},${pal.cream.b},${0.96})`);
        grad.addColorStop(0.22, `rgba(${pal.honey.r},${pal.honey.g},${pal.honey.b},${0.74})`);
        grad.addColorStop(0.55, `rgba(${pal.ember.r},${pal.ember.g},${pal.ember.b},${0.38})`);
        grad.addColorStop(0.86, `rgba(${pal.rim.r},${pal.rim.g},${pal.rim.b},${0.18})`);
        grad.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;

        // silhouette
        ctx.beginPath();
        ctx.moveTo(0, -rr*1.12);
        ctx.quadraticCurveTo(rr*1.05, -rr*0.35, rr*0.78, 0);
        ctx.quadraticCurveTo(rr*0.20, rr*0.98, 0, rr*1.10);
        ctx.quadraticCurveTo(-rr*0.20, rr*0.98, -rr*0.78, 0);
        ctx.quadraticCurveTo(-rr*1.05, -rr*0.35, 0, -rr*1.12);
        ctx.closePath();
        ctx.fill();

        // ribs
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.10 + 0.12*glowUp;
        ctx.strokeStyle = `rgba(255,255,255,${0.18})`;
        ctx.lineWidth = 1;
        for (let k=-2;k<=2;k++){
          const x = (k/2) * rr*0.35;
          ctx.beginPath();
          ctx.moveTo(x, -rr*0.92);
          ctx.quadraticCurveTo(x*1.15, 0, x, rr*0.95);
          ctx.stroke();
        }
        ctx.restore();

        // inner flame
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.45 + 0.35*Math.sin(tSec*2.2 + p.id);
        ctx.fillStyle = `rgba(255,255,255,${0.92})`;
        ctx.filter = 'blur(0.6px)';
        ctx.beginPath();
        ctx.ellipse(0, rr*0.15, rr*0.22, rr*0.55, 0.18*Math.sin(tSec+p.id), 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        // top cap + hook
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.35 + 0.22*glowUp;
        ctx.fillStyle = `rgba(255,255,255,${0.66})`;
        ctx.beginPath();
        ctx.roundRect(-rr*0.36, -rr*1.28, rr*0.72, rr*0.26, rr*0.12);
        ctx.fill();

        ctx.strokeStyle = `rgba(255,255,255,${0.35})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, -rr*1.35, rr*0.22, Math.PI*0.05, Math.PI*0.95);
        ctx.stroke();
        ctx.restore();

        ctx.restore();
      }

      // ---------- Celestial animation states ----------
      function updateCelestialIdle(obj, nowMs){
        const t = nowMs * 0.001;
        obj.scale = 1 + 0.020 * Math.sin(t * 2 * Math.PI / 6.2);
        obj.intensity = 1.0 + 0.06 * (0.5 + 0.5*Math.sin(t * 2*Math.PI / 7.2));
      }

      function startBloom(obj, nowMs){
        pickNewPalette(nowMs);
        obj.state = 'bloomUp';
        obj.t0 = nowMs;
      }
      function startWarp(obj, nowMs){
        pickNewPalette(nowMs);
        obj.state = 'warpUp';
        obj.t0 = nowMs;
      }

      function updateCelestial(obj, nowMs, opts){
        const { bloomScale=3.0, warpScale=5.0, onWarpComplete=null } = opts || {};

        if (obj.state === 'idle'){
          updateCelestialIdle(obj, nowMs);
          return;
        }

        if (obj.state === 'bloomUp'){
          const t = clamp((nowMs - obj.t0) / obj.bloomUpMs, 0, 1);
          const e = easeInOutCubic(t);
          obj.scale = lerp(1.0, bloomScale, e);

          const quick = easeOutCubic(clamp(t / 0.10, 0, 1));
          const long = easeInOutCubic(clamp((t - 0.05) / 0.95, 0, 1));
          obj.intensity = 1.05 + 0.30 * quick + 0.90 * long;

          if (t >= 1){
            obj.state = 'return';
            obj.t0 = nowMs;
          }
          return;
        }

        if (obj.state === 'return'){
          const t = clamp((nowMs - obj.t0) / obj.returnMs, 0, 1);
          const e = easeOutCubic(t);
          obj.scale = lerp(bloomScale, 1.0, e);

          const linger = 1 - 0.35 * e;
          obj.intensity = (1.25 * linger) + 0.05;

          if (t >= 1){
            obj.state = 'idle';
            obj.t0 = nowMs;
          }
          return;
        }

        if (obj.state === 'warpUp'){
          const t = clamp((nowMs - obj.t0) / obj.warpUpMs, 0, 1);
          const e = easeInOutCubic(t);
          obj.scale = lerp(1.0, warpScale, e);
          obj.intensity = 1.10 + 1.10 * easeOutCubic(t);
          if (t >= 1){
            obj.state = 'warpHold';
            obj.t0 = nowMs;
          }
          return;
        }

        if (obj.state === 'warpHold'){
          const t = clamp((nowMs - obj.t0) / obj.warpHoldMs, 0, 1);
          obj.scale = warpScale * (1 + 0.02*Math.sin(nowMs*0.01));
          obj.intensity = 2.2;
          if (t >= 1){
            obj.state = 'warpDown';
            obj.t0 = nowMs;
          }
          return;
        }

        if (obj.state === 'warpDown'){
          const t = clamp((nowMs - obj.t0) / obj.warpDownMs, 0, 1);
          const e = easeOutCubic(t);
          obj.scale = lerp(warpScale, warpScale*0.92, e);
          obj.intensity = lerp(2.2, 1.2, e);

          if (t >= 1){
            obj.state = 'idle';
            obj.scale = 1;
            obj.intensity = 1;
            obj.t0 = nowMs;
            if (typeof onWarpComplete === 'function') onWarpComplete();
          }
        }
      }

      // ---------- Satellite motion ----------
      function updateSatellitePositions(dt){
        for (const s of satellites){
          if (s.dragging) continue;
          s.angle += s.omega * dt;
          s.x = star.cx + Math.cos(s.angle) * s.orbitRadius;
          s.y = star.cy + Math.sin(s.angle) * s.orbitRadius;
        }
      }
      function setSatelliteOrbitFromPosition(s){
        const dx = s.x - star.cx;
        const dy = s.y - star.cy;
        const r = Math.sqrt(dx*dx + dy*dy);
        s.orbitRadius = clamp(r, star.rBase * 0.85, Math.min(w,h) * 0.48);
        s.angle = Math.atan2(dy, dx);
      }
      function startSatelliteSwell(s, nowMs){
        s.state = 'swellUp';
        s.t0 = nowMs;
      }
      function updateSatelliteSwell(s, nowMs){
        if (s.state === 'idle'){
          const t = nowMs * 0.001;
          s.scale = 1 + 0.010 * Math.sin(t * 2*Math.PI / (5.2 + s.id*0.6));
          return;
        }
        if (s.state === 'swellUp'){
          const t = clamp((nowMs - s.t0) / s.swellUpMs, 0, 1);
          s.scale = lerp(1.0, 1.85, easeOutCubic(t));
          if (t >= 1){
            s.state = 'return';
            s.t0 = nowMs;
          }
          return;
        }
        if (s.state === 'return'){
          const t = clamp((nowMs - s.t0) / s.returnMs, 0, 1);
          s.scale = lerp(1.85, 1.0, easeOutCubic(t));
          if (t >= 1) s.state = 'idle';
        }
      }

      // ---------- Hit tests ----------
      function inHitCircle(x,y,cx,cy,r){
        const dx = x - cx, dy = y - cy;
        return (dx*dx + dy*dy) <= r*r;
      }
      function hitSatellite(x,y){
        for (let i = satellites.length - 1; i >= 0; i--){
          const s = satellites[i];
          const rr = s.rBase * 1.75;
          if (inHitCircle(x,y,s.x,s.y,rr)) return i;
        }
        return -1;
      }
      function hitLantern(x,y){
        for (let i = lanterns.length - 1; i >= 0; i--){
          const p = lanterns[i];
          if (inHitCircle(x,y,p.x,p.y,p.r*1.55)) return i;
        }
        return -1;
      }

      // ---------- Double tap ----------
      const dbl = { lastKey:'', lastT:0, maxGap:360 };
      function isDoubleTap(key, now){
        if (dbl.lastKey === key && (now - dbl.lastT) <= dbl.maxGap){
          dbl.lastKey = '';
          dbl.lastT = 0;
          return true;
        }
        dbl.lastKey = key;
        dbl.lastT = now;
        return false;
      }

      // ---------- Drag ----------
      const drag = { active:false, satIndex:-1, pointerId:null };

      // ---------- Scene navigation ----------
      function goToScene(next){
        scene = next;
        updateBackButton();

        messagePlaying = false;
        clearMessageTimers();
        hideMessage();

        dbl.lastKey = '';
        dbl.lastT = 0;

        moon.glow = 0;
        for (const p of lanterns) p.glow = 0;

        if (scene === 'planet'){
          showOneShot("Welcome to Boo Planet.\nTap the moon for moon facts.\nDouble tap Boo Planet to visit the Lantern Sky.", 7000);
        } else if (scene === 'lantern'){
          showOneShot("Lantern Sky.\nTap a lantern to discover a world holiday.\nTap it again to change its colour.", 6200);
        } else if (scene === 'star'){
          showOneShot("Tip: Double tap the star to travel to Boo Planet.", 5200);
        }
      }

      backBtn.addEventListener('click', () => {
        if (!allowInput) return;
        if (scene === 'lantern') goToScene('planet');
        else if (scene === 'planet') goToScene('star');
      });

      // ---------- Input ----------
      canvas.addEventListener('pointerdown', (e) => {
        if (!allowInput) return;

        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);
        const now = performance.now();

        if (scene === 'lantern'){
          const li = hitLantern(x,y);
          if (li !== -1){
            const p = lanterns[li];

            // toggle vivid + cycle colour
            if (p.mode !== 'vivid'){
              p.mode = 'vivid';
            } else {
              p.vividIndex = (p.vividIndex + 1) % VIVID_COLORS.length;
            }

            // glow up + tiny bump so it feels responsive
            p.glow = 1;
            p.vx += rand(-25,25);
            p.vy += rand(-22,22);

            // holiday message
            const idx = holidayOrder[holidayPtr % holidayOrder.length];
            holidayPtr++;
            showOneShot(HOLIDAY_MESSAGES[idx], 6800);
          }
          return;
        }

        if (scene === 'planet'){
          if (inHitCircle(x,y,moon.x,moon.y,moon.rBase*1.6)){
            moon.glow = 1;
            const fact = MOON_FACTS[moonFactIndex % MOON_FACTS.length];
            moonFactIndex++;
            showOneShot(fact, 5600);
            return;
          }

          const planetR = booPlanet.rBase * 1.25;
          if (inHitCircle(x,y,booPlanet.cx,booPlanet.cy,planetR)){
            const key = 'planet:boo';
            if (isDoubleTap(key, now)){
              startWarp(booPlanet, now);
              return;
            } else {
              if (booPlanet.state === 'idle') startBloom(booPlanet, now);
              return;
            }
          }
          return;
        }

        // star scene
        const idx = hitSatellite(x,y);
        if (idx !== -1){
          const s = satellites[idx];
          startSatelliteSwell(s, now);

          drag.active = true;
          drag.satIndex = idx;
          drag.pointerId = e.pointerId;
          s.dragging = true;
          s.x = x; s.y = y;
          canvas.setPointerCapture?.(e.pointerId);
          return;
        }

        const starR = star.rBase * 1.22;
        if (inHitCircle(x,y,star.cx,star.cy,starR)){
          const key = 'star:center';
          if (isDoubleTap(key, now)){
            startWarp(star, now);
            return;
          } else {
            if (star.state === 'idle') startBloom(star, now);
            pickNewPalette(now);
            return;
          }
        }
      }, { passive:false });

      canvas.addEventListener('pointermove', (e) => {
        if (!allowInput) return;
        if (scene !== 'star') return;
        if (!drag.active) return;
        if (drag.pointerId !== e.pointerId) return;

        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);

        const s = satellites[drag.satIndex];
        if (!s) return;

        s.x = x;
        s.y = y;
      }, { passive:false });

      function endDrag(e){
        if (!drag.active) return;
        if (drag.pointerId !== e.pointerId) return;

        const s = satellites[drag.satIndex];
        if (s){
          s.dragging = false;
          setSatelliteOrbitFromPosition(s);
        }

        drag.active = false;
        drag.satIndex = -1;
        drag.pointerId = null;
      }
      canvas.addEventListener('pointerup', endDrag, { passive:true });
      canvas.addEventListener('pointercancel', endDrag, { passive:true });

      // ---------- Welcome / Start ----------
      async function startMusic(){
        try{
          if (bgm && bgm.paused){
            bgm.volume = 0.45;
            await bgm.play();
          }
        }catch(_e){}
      }

      function setScreen(which){
        welcome.classList.toggle('active', which === 'welcome');
        play.classList.toggle('active', which === 'play');
      }

      startBtn.addEventListener('click', async () => {
        await startMusic();
        setScreen('play');
        pressToPlay.style.display = 'block';
        allowInput = true;

        scene = 'star';
        updateBackButton();
        showOneShot("Tip: Double tap the star to travel to Boo Planet.", 5200);
      });

      // ---------- Animation loop ----------
      let lastMs = performance.now();

      function tick(nowMs){
        const dt = (nowMs - lastMs) * 0.001;
        lastMs = nowMs;
        const tSec = nowMs * 0.001;

        updatePalette(nowMs);
        drawBackground(tSec);

        // rotations
        star.rot  += dt * 0.18;  star.rot2 += dt * 0.11;
        booPlanet.rot  += dt * 0.16; booPlanet.rot2 += dt * 0.10;

        if (scene === 'star'){
          updateCelestial(star, nowMs, {
            bloomScale: 3.0,
            warpScale: 5.0,
            onWarpComplete: () => goToScene('planet')
          });

          updateSatellitePositions(dt);
          for (const s of satellites) updateSatelliteSwell(s, nowMs);

          for (const s of satellites) drawSatellite(s);
          drawCelestial(star, tSec);
        }

        if (scene === 'planet'){
          updateCelestial(booPlanet, nowMs, {
            bloomScale: 2.4,
            warpScale: 5.0,
            onWarpComplete: () => {
              // entering lantern scene: no Boo Planet rendered here anymore
              initLanterns(true);
              goToScene('lantern');
            }
          });

          updateMoon(dt);

          drawCelestial(booPlanet, tSec);
          drawMoon(tSec);
        }

        if (scene === 'lantern'){
          // ✅ Boo Planet removed: only lantern sky
          updateLanterns(dt, tSec);
          for (const p of lanterns) drawLantern(p, tSec);
        }

        updateBackButton();
        requestAnimationFrame(tick);
      }

      // ---------- Safety ----------
      document.addEventListener('visibilitychange', () => {
        if (document.hidden){
          for (const obj of [star, booPlanet]){
            obj.state = 'idle';
            obj.scale = 1;
            obj.intensity = 1;
          }
          for (const s of satellites){
            s.state = 'idle';
            s.scale = 1;
            s.dragging = false;
            setSatelliteOrbitFromPosition(s);
          }
          drag.active = false;
          drag.satIndex = -1;
          drag.pointerId = null;

          messagePlaying = false;
          clearMessageTimers();
          hideMessage();
        }
      });

      // ---------- Start ----------
      resize();
      initSatellites(true);
      initLanterns(true);

      moon.angle = rand(0, Math.PI*2);
      moonFactIndex = 0;

      requestAnimationFrame(tick);
    })();
  </script>
</body>
</html>
